{
  "modules": [
    {
      "kind": "module",
      "mainExport": {
        "kind": "typeIndexRef",
        "link": "(framework/app).App"
      },
      "namedExports": [
        {
          "kind": "export",
          "name": "log",
          "type": {
            "kind": "typeIndexRef",
            "link": "(lib/logger/logger).Logger"
          },
          "isType": false,
          "isTerm": true
        },
        {
          "kind": "export",
          "name": "schema",
          "type": {
            "kind": "intersection",
            "raw": {
              "typeText": "Schema & { addToContext: <Req extends any = Request, T extends {} = any>(contextContributor: ContextContributor<Req, T>) => void; }",
              "nodeFullText": "",
              "nodeText": ""
            },
            "types": [
              {
                "kind": "typeIndexRef",
                "link": "(framework/schema/schema).Schema"
              },
              {
                "kind": "object",
                "props": [
                  {
                    "kind": "prop",
                    "name": "addToContext",
                    "type": {
                      "kind": "callable",
                      "isOverloaded": false,
                      "hasProps": false,
                      "props": [],
                      "sigs": [
                        {
                          "kind": "sig",
                          "return": {
                            "kind": "primitive",
                            "type": "void"
                          },
                          "params": [
                            {
                              "kind": "sigParam",
                              "name": "contextContributor",
                              "type": {
                                "kind": "typeIndexRef",
                                "link": "(framework/app).ContextContributor"
                              }
                            }
                          ]
                        }
                      ],
                      "raw": {
                        "typeText": "<Req extends any = Request, T extends {} = any>(contextContributor: ContextContributor<Req, T>) => void",
                        "nodeText": "<Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void",
                        "nodeFullText": "<Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void"
                      }
                    }
                  }
                ],
                "raw": {
                  "typeText": "{ addToContext: <Req extends any = Request, T extends {} = any>(contextContributor: ContextContributor<Req, T>) => void; }",
                  "nodeText": "{\n    // addToContext is a bridge between two components, schema and server, so\n    // its not in schema currently...\n\n    /**\n     * todo\n     */\n    addToContext: <Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void\n  }",
                  "nodeFullText": "{\n    // addToContext is a bridge between two components, schema and server, so\n    // its not in schema currently...\n\n    /**\n     * todo\n     */\n    addToContext: <Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void\n  }"
                }
              }
            ]
          },
          "isType": false,
          "isTerm": true
        },
        {
          "kind": "export",
          "name": "server",
          "type": {
            "kind": "typeIndexRef",
            "link": "(framework/server).ServerWithCustomizer"
          },
          "isType": false,
          "isTerm": true
        },
        {
          "kind": "export",
          "name": "settings",
          "type": {
            "kind": "typeIndexRef",
            "link": "(framework/app).Settings"
          },
          "isType": false,
          "isTerm": true
        }
      ],
      "name": "index",
      "jsdoc": {
        "raw": "/**\n * Exports the singleton app components. Use to build up your GraphQL schema and server.\n */",
        "summary": "Exports the singleton app components. Use to build up your GraphQL schema and server.\n",
        "tags": []
      },
      "path": "/",
      "isMain": true,
      "location": {
        "absoluteFilePath": "/Users/jasonkuhrt/projects/nexus/nexus-future/src/index.ts"
      }
    },
    {
      "kind": "module",
      "mainExport": null,
      "namedExports": [
        {
          "kind": "export",
          "name": "createTestContext",
          "type": {
            "kind": "callable",
            "isOverloaded": false,
            "hasProps": false,
            "props": [],
            "sigs": [
              {
                "kind": "sig",
                "return": {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "Promise<nexusFutureTestContextRoot>",
                    "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                    "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                  }
                },
                "params": []
              }
            ],
            "raw": {
              "typeText": "() => Promise<nexusFutureTestContextRoot>",
              "nodeText": "export async function createTestContext(): Promise<TestContext> {\n  // Guarantee that development mode features are on\n  process.env.NEXUS_STAGE = 'dev'\n\n  const port = await getPort({ port: getPort.makeRange(4000, 6000) })\n  const apiUrl = `http://localhost:${port}/graphql`\n\n  const oldServerStart = app.server.start\n\n  app.server.start = async () => {\n    const appModule = await Layout.findAppModule()\n\n    if (appModule) {\n      require(appModule)\n    }\n\n    app.settings.change({\n      server: {\n        port,\n        playground: false,\n        startMessage: () => '',\n      },\n    })\n\n    if (singletonChecks.state.is_was_server_start_called === false) {\n      await oldServerStart()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  const appClient = createAppClient(apiUrl)\n  const testContextCore: TestContextCore = {\n    app: {\n      query: appClient.query,\n      server: {\n        start: app.server.start,\n        stop: app.server.stop,\n      },\n    },\n  }\n\n  const testContextContributions = await Plugin.loadAllTestingPluginsFromPackageJson()\n\n  for (const testContextContribution of testContextContributions) {\n    Lo.merge(testContextCore, testContextContribution)\n  }\n\n  return testContextCore as TestContext\n}",
              "nodeFullText": "/**\n * Setup a test context providing utilities to query against your GraphQL API\n *\n * @example\n *\n * With jest\n * ```\n * import { setupTest, TestContext } from 'nexus-future/testing'\n *\n * let testCtx: TestContext\n *\n * beforeAll(async () => {\n *  testCtx = await setupTest()\n *  await testCtx.server.start()\n * })\n *\n * afterAll(async () => {\n *  await testCtx.server.stop()\n * })\n * ```\n */\nexport async function createTestContext(): Promise<TestContext> {\n  // Guarantee that development mode features are on\n  process.env.NEXUS_STAGE = 'dev'\n\n  const port = await getPort({ port: getPort.makeRange(4000, 6000) })\n  const apiUrl = `http://localhost:${port}/graphql`\n\n  const oldServerStart = app.server.start\n\n  app.server.start = async () => {\n    const appModule = await Layout.findAppModule()\n\n    if (appModule) {\n      require(appModule)\n    }\n\n    app.settings.change({\n      server: {\n        port,\n        playground: false,\n        startMessage: () => '',\n      },\n    })\n\n    if (singletonChecks.state.is_was_server_start_called === false) {\n      await oldServerStart()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  const appClient = createAppClient(apiUrl)\n  const testContextCore: TestContextCore = {\n    app: {\n      query: appClient.query,\n      server: {\n        start: app.server.start,\n        stop: app.server.stop,\n      },\n    },\n  }\n\n  const testContextContributions = await Plugin.loadAllTestingPluginsFromPackageJson()\n\n  for (const testContextContribution of testContextContributions) {\n    Lo.merge(testContextCore, testContextContribution)\n  }\n\n  return testContextCore as TestContext\n}"
            }
          },
          "isType": false,
          "isTerm": true
        },
        {
          "kind": "export",
          "name": "TestContext",
          "type": {
            "kind": "typeIndexRef",
            "link": "(framework/testing).TestContext"
          },
          "isType": true,
          "isTerm": false
        }
      ],
      "name": "testing",
      "jsdoc": null,
      "path": "/testing",
      "isMain": false,
      "location": {
        "absoluteFilePath": "/Users/jasonkuhrt/projects/nexus/nexus-future/src/testing.ts"
      }
    },
    {
      "kind": "module",
      "mainExport": null,
      "namedExports": [
        {
          "kind": "export",
          "name": "create",
          "type": {
            "kind": "callable",
            "isOverloaded": false,
            "hasProps": false,
            "props": [],
            "sigs": [
              {
                "kind": "sig",
                "return": {
                  "kind": "typeIndexRef",
                  "link": "(core/plugin/index).DriverCreator"
                },
                "params": [
                  {
                    "kind": "sigParam",
                    "name": "definer",
                    "type": {
                      "kind": "typeIndexRef",
                      "link": "(core/plugin/index).Definer"
                    }
                  }
                ]
              }
            ],
            "raw": {
              "typeText": "(definer: Definer) => DriverCreator",
              "nodeText": "export function create(definer: Definer): DriverCreator {\n  let maybeWorkflowPlugin: undefined | WorkflowDefiner\n  let maybeRuntimePlugin: undefined | RuntimePlugin\n  let maybeTestingPlugin: undefined | TestingPlugin\n\n  return pluginName => {\n    definer({\n      runtime(f) {\n        maybeRuntimePlugin = f\n      },\n      workflow(f) {\n        maybeWorkflowPlugin = f\n      },\n      testing(f) {\n        maybeTestingPlugin = f\n      },\n      utils: {\n        log: pluginSystemLogger.child(pluginName),\n        run,\n        runSync,\n        prompt: prompts,\n      },\n    })\n\n    return {\n      name: pluginName,\n      extendsWorkflow: maybeWorkflowPlugin !== undefined,\n      extendsRuntime: maybeRuntimePlugin !== undefined,\n      extendsTesting: maybeTestingPlugin !== undefined,\n      loadWorkflowPlugin(layout) {\n        const hooks: WorkflowHooks = {\n          create: {},\n          dev: {\n            addToWatcherSettings: {},\n          },\n          build: {},\n          generate: {},\n        }\n        log.trace('loading workflow of plugin', { pluginName })\n        maybeWorkflowPlugin?.(hooks, {\n          layout,\n          packageManager: layout.packageManager,\n        })\n        return hooks\n      },\n      loadRuntimePlugin() {\n        log.trace('loading runtime of plugin', { pluginName })\n        return maybeRuntimePlugin?.()\n      },\n      loadTestingPlugin() {\n        log.trace('loading testing of plugin', { pluginName })\n        return maybeTestingPlugin?.()\n      },\n    }\n  }\n}",
              "nodeFullText": "/**\n * Create a plugin.\n */\nexport function create(definer: Definer): DriverCreator {\n  let maybeWorkflowPlugin: undefined | WorkflowDefiner\n  let maybeRuntimePlugin: undefined | RuntimePlugin\n  let maybeTestingPlugin: undefined | TestingPlugin\n\n  return pluginName => {\n    definer({\n      runtime(f) {\n        maybeRuntimePlugin = f\n      },\n      workflow(f) {\n        maybeWorkflowPlugin = f\n      },\n      testing(f) {\n        maybeTestingPlugin = f\n      },\n      utils: {\n        log: pluginSystemLogger.child(pluginName),\n        run,\n        runSync,\n        prompt: prompts,\n      },\n    })\n\n    return {\n      name: pluginName,\n      extendsWorkflow: maybeWorkflowPlugin !== undefined,\n      extendsRuntime: maybeRuntimePlugin !== undefined,\n      extendsTesting: maybeTestingPlugin !== undefined,\n      loadWorkflowPlugin(layout) {\n        const hooks: WorkflowHooks = {\n          create: {},\n          dev: {\n            addToWatcherSettings: {},\n          },\n          build: {},\n          generate: {},\n        }\n        log.trace('loading workflow of plugin', { pluginName })\n        maybeWorkflowPlugin?.(hooks, {\n          layout,\n          packageManager: layout.packageManager,\n        })\n        return hooks\n      },\n      loadRuntimePlugin() {\n        log.trace('loading runtime of plugin', { pluginName })\n        return maybeRuntimePlugin?.()\n      },\n      loadTestingPlugin() {\n        log.trace('loading testing of plugin', { pluginName })\n        return maybeTestingPlugin?.()\n      },\n    }\n  }\n}"
            }
          },
          "isType": false,
          "isTerm": true
        },
        {
          "kind": "export",
          "name": "Lens",
          "type": {
            "kind": "typeIndexRef",
            "link": "(core/plugin/index).Lens"
          },
          "isType": true,
          "isTerm": false
        }
      ],
      "name": "plugin",
      "jsdoc": null,
      "path": "/plugin",
      "isMain": false,
      "location": {
        "absoluteFilePath": "/Users/jasonkuhrt/projects/nexus/nexus-future/src/plugin.ts"
      }
    }
  ],
  "typeIndex": {
    "(framework/app).App": {
      "kind": "alias",
      "name": "App",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "log",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/logger/logger).Logger"
            }
          },
          {
            "kind": "prop",
            "name": "server",
            "type": {
              "kind": "typeIndexRef",
              "link": "(framework/server).ServerWithCustomizer"
            }
          },
          {
            "kind": "prop",
            "name": "settings",
            "type": {
              "kind": "typeIndexRef",
              "link": "(framework/app).Settings"
            }
          },
          {
            "kind": "prop",
            "name": "schema",
            "type": {
              "kind": "intersection",
              "raw": {
                "typeText": "Schema & { addToContext: <Req extends any = Request, T extends {} = any>(contextContributor: ContextContributor<Req, T>) => void; }",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "typeIndexRef",
                  "link": "(framework/schema/schema).Schema"
                },
                {
                  "kind": "object",
                  "props": [
                    {
                      "kind": "prop",
                      "name": "addToContext",
                      "type": {
                        "kind": "callable",
                        "isOverloaded": false,
                        "hasProps": false,
                        "props": [],
                        "sigs": [
                          {
                            "kind": "sig",
                            "return": {
                              "kind": "primitive",
                              "type": "void"
                            },
                            "params": [
                              {
                                "kind": "sigParam",
                                "name": "contextContributor",
                                "type": {
                                  "kind": "typeIndexRef",
                                  "link": "(framework/app).ContextContributor"
                                }
                              }
                            ]
                          }
                        ],
                        "raw": {
                          "typeText": "<Req extends any = Request, T extends {} = any>(contextContributor: ContextContributor<Req, T>) => void",
                          "nodeText": "<Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void",
                          "nodeFullText": "<Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void"
                        }
                      }
                    }
                  ],
                  "raw": {
                    "typeText": "{ addToContext: <Req extends any = Request, T extends {} = any>(contextContributor: ContextContributor<Req, T>) => void; }",
                    "nodeText": "{\n    // addToContext is a bridge between two components, schema and server, so\n    // its not in schema currently...\n\n    /**\n     * todo\n     */\n    addToContext: <Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void\n  }",
                    "nodeFullText": "{\n    // addToContext is a bridge between two components, schema and server, so\n    // its not in schema currently...\n\n    /**\n     * todo\n     */\n    addToContext: <Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void\n  }"
                  }
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "App",
          "nodeText": "export type App = {\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=logger)  ⌁  [Guide](https://nexus-future.now.sh/#/guides/logging)\n   *\n   * ### todo\n   */\n  log: Logger.Logger\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=server)  ⌁  [Guide](todo)\n   *\n   * ### todo\n   *\n   */\n  server: Server.ServerWithCustomizer\n  /**\n   * todo\n   */\n  settings: Settings\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=appschema) // [Guide](todo)\n   *\n   * ### todo\n   */\n  schema: Schema.Schema & {\n    // addToContext is a bridge between two components, schema and server, so\n    // its not in schema currently...\n\n    /**\n     * todo\n     */\n    addToContext: <Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void\n  }\n}",
          "nodeFullText": "export type App = {\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=logger)  ⌁  [Guide](https://nexus-future.now.sh/#/guides/logging)\n   *\n   * ### todo\n   */\n  log: Logger.Logger\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=server)  ⌁  [Guide](todo)\n   *\n   * ### todo\n   *\n   */\n  server: Server.ServerWithCustomizer\n  /**\n   * todo\n   */\n  settings: Settings\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=appschema) // [Guide](todo)\n   *\n   * ### todo\n   */\n  schema: Schema.Schema & {\n    // addToContext is a bridge between two components, schema and server, so\n    // its not in schema currently...\n\n    /**\n     * todo\n     */\n    addToContext: <Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void\n  }\n}"
        }
      },
      "raw": {
        "typeText": "App",
        "nodeText": "export type App = {\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=logger)  ⌁  [Guide](https://nexus-future.now.sh/#/guides/logging)\n   *\n   * ### todo\n   */\n  log: Logger.Logger\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=server)  ⌁  [Guide](todo)\n   *\n   * ### todo\n   *\n   */\n  server: Server.ServerWithCustomizer\n  /**\n   * todo\n   */\n  settings: Settings\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=appschema) // [Guide](todo)\n   *\n   * ### todo\n   */\n  schema: Schema.Schema & {\n    // addToContext is a bridge between two components, schema and server, so\n    // its not in schema currently...\n\n    /**\n     * todo\n     */\n    addToContext: <Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void\n  }\n}",
        "nodeFullText": "export type App = {\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=logger)  ⌁  [Guide](https://nexus-future.now.sh/#/guides/logging)\n   *\n   * ### todo\n   */\n  log: Logger.Logger\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=server)  ⌁  [Guide](todo)\n   *\n   * ### todo\n   *\n   */\n  server: Server.ServerWithCustomizer\n  /**\n   * todo\n   */\n  settings: Settings\n  /**\n   * [API Reference](https://nexus-future.now.sh/#/references/api?id=appschema) // [Guide](todo)\n   *\n   * ### todo\n   */\n  schema: Schema.Schema & {\n    // addToContext is a bridge between two components, schema and server, so\n    // its not in schema currently...\n\n    /**\n     * todo\n     */\n    addToContext: <Req extends any = Request, T extends {} = any>(\n      contextContributor: ContextContributor<Req, T>\n    ) => void\n  }\n}"
      }
    },
    "(lib/logger/logger).Logger": {
      "kind": "alias",
      "name": "Logger",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "fatal",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/logger/logger).Log"
            }
          },
          {
            "kind": "prop",
            "name": "error",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/logger/logger).Log"
            }
          },
          {
            "kind": "prop",
            "name": "warn",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/logger/logger).Log"
            }
          },
          {
            "kind": "prop",
            "name": "info",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/logger/logger).Log"
            }
          },
          {
            "kind": "prop",
            "name": "debug",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/logger/logger).Log"
            }
          },
          {
            "kind": "prop",
            "name": "trace",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/logger/logger).Log"
            }
          },
          {
            "kind": "prop",
            "name": "addToContext",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "typeIndexRef",
                    "link": "(lib/logger/logger).Logger"
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "context",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Record<string, unknown>",
                          "nodeText": "type Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};",
                          "nodeFullText": "/**\r\n * Construct a type with a set of properties K of type T\r\n */\r\ntype Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};"
                        }
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(context: Record<string, unknown>) => Logger",
                "nodeText": "(context: Context) => Logger",
                "nodeFullText": "(context: Context) => Logger"
              }
            }
          },
          {
            "kind": "prop",
            "name": "child",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "typeIndexRef",
                    "link": "(lib/logger/logger).Logger"
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "name",
                      "type": {
                        "kind": "primitive",
                        "type": "string"
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(name: string) => Logger",
                "nodeText": "(name: string) => Logger",
                "nodeFullText": "(name: string) => Logger"
              }
            }
          }
        ],
        "raw": {
          "typeText": "Logger",
          "nodeText": "export type Logger = {\n  fatal: Log\n  error: Log\n  warn: Log\n  info: Log\n  debug: Log\n  trace: Log\n  addToContext: (context: Context) => Logger // fluent\n  child: (name: string) => Logger // fluent\n}",
          "nodeFullText": "export type Logger = {\n  fatal: Log\n  error: Log\n  warn: Log\n  info: Log\n  debug: Log\n  trace: Log\n  addToContext: (context: Context) => Logger // fluent\n  child: (name: string) => Logger // fluent\n}"
        }
      },
      "raw": {
        "typeText": "Logger",
        "nodeText": "export type Logger = {\n  fatal: Log\n  error: Log\n  warn: Log\n  info: Log\n  debug: Log\n  trace: Log\n  addToContext: (context: Context) => Logger // fluent\n  child: (name: string) => Logger // fluent\n}",
        "nodeFullText": "export type Logger = {\n  fatal: Log\n  error: Log\n  warn: Log\n  info: Log\n  debug: Log\n  trace: Log\n  addToContext: (context: Context) => Logger // fluent\n  child: (name: string) => Logger // fluent\n}"
      }
    },
    "(lib/logger/logger).Log": {
      "kind": "alias",
      "name": "Log",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "primitive",
              "type": "void"
            },
            "params": [
              {
                "kind": "sigParam",
                "name": "event",
                "type": {
                  "kind": "primitive",
                  "type": "string"
                }
              },
              {
                "kind": "sigParam",
                "name": "context",
                "type": {
                  "kind": "union",
                  "isDiscriminated": false,
                  "discriminantProperties": null,
                  "raw": {
                    "typeText": "Record<string, unknown> | undefined",
                    "nodeFullText": "",
                    "nodeText": ""
                  },
                  "types": [
                    {
                      "kind": "primitive",
                      "type": "undefined"
                    },
                    {
                      "kind": "alias",
                      "name": "Record",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Record<string, unknown>",
                          "nodeText": "type Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};",
                          "nodeFullText": "/**\r\n * Construct a type with a set of properties K of type T\r\n */\r\ntype Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};"
                        }
                      },
                      "raw": {
                        "typeText": "Record<string, unknown>",
                        "nodeText": "type Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};",
                        "nodeFullText": "/**\r\n * Construct a type with a set of properties K of type T\r\n */\r\ntype Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};"
                      }
                    }
                  ]
                }
              }
            ]
          }
        ],
        "raw": {
          "typeText": "Log",
          "nodeText": "type Log = (event: string, context?: Context) => void",
          "nodeFullText": "type Log = (event: string, context?: Context) => void"
        }
      },
      "raw": {
        "typeText": "Log",
        "nodeText": "type Log = (event: string, context?: Context) => void",
        "nodeFullText": "type Log = (event: string, context?: Context) => void"
      }
    },
    "(framework/server).ServerWithCustomizer": {
      "kind": "interface",
      "name": "ServerWithCustomizer",
      "props": [
        {
          "kind": "prop",
          "name": "custom",
          "type": {
            "kind": "callable",
            "isOverloaded": false,
            "hasProps": false,
            "props": [],
            "sigs": [
              {
                "kind": "sig",
                "return": {
                  "kind": "primitive",
                  "type": "void"
                },
                "params": [
                  {
                    "kind": "sigParam",
                    "name": "customizer",
                    "type": {
                      "kind": "typeIndexRef",
                      "link": "(framework/server).Customizer"
                    }
                  }
                ]
              }
            ],
            "raw": {
              "typeText": "(customizer: Customizer) => void",
              "nodeText": "(customizer: Customizer) => void",
              "nodeFullText": "(customizer: Customizer) => void"
            }
          }
        },
        {
          "kind": "prop",
          "name": "start",
          "type": {
            "kind": "callable",
            "isOverloaded": false,
            "hasProps": false,
            "props": [],
            "sigs": [
              {
                "kind": "sig",
                "return": {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "Promise<void>",
                    "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                    "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                  }
                },
                "params": []
              }
            ],
            "raw": {
              "typeText": "() => Promise<void>",
              "nodeText": "start(): Promise<void>",
              "nodeFullText": "/**\n   * Start the server instance\n   */\n  start(): Promise<void>"
            }
          }
        },
        {
          "kind": "prop",
          "name": "stop",
          "type": {
            "kind": "callable",
            "isOverloaded": false,
            "hasProps": false,
            "props": [],
            "sigs": [
              {
                "kind": "sig",
                "return": {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "Promise<void>",
                    "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                    "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                  }
                },
                "params": []
              }
            ],
            "raw": {
              "typeText": "() => Promise<void>",
              "nodeText": "stop(): Promise<void>",
              "nodeFullText": "/**\n   * Stop the server instance\n   */\n  stop(): Promise<void>"
            }
          }
        }
      ],
      "jsdoc": null,
      "raw": {
        "typeText": "ServerWithCustomizer",
        "nodeText": "export interface ServerWithCustomizer extends Server {\n  /**\n   * Provides a way to use a custom GraphQL server such as Apollo Server or Fastify\n   */\n  custom: (customizer: Customizer) => void\n}",
        "nodeFullText": "export interface ServerWithCustomizer extends Server {\n  /**\n   * Provides a way to use a custom GraphQL server such as Apollo Server or Fastify\n   */\n  custom: (customizer: Customizer) => void\n}"
      }
    },
    "(framework/server).Customizer": {
      "kind": "alias",
      "name": "Customizer",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "typeIndexRef",
              "link": "(lib/utils/index).MaybePromise"
            },
            "params": [
              {
                "kind": "sigParam",
                "name": "lens",
                "type": {
                  "kind": "typeIndexRef",
                  "link": "(framework/server).CustomizerLens"
                }
              }
            ]
          }
        ],
        "raw": {
          "typeText": "Customizer",
          "nodeText": "export type Customizer = (\n  lens: CustomizerLens\n) => Utils.MaybePromise<Server | void>",
          "nodeFullText": "export type Customizer = (\n  lens: CustomizerLens\n) => Utils.MaybePromise<Server | void>"
        }
      },
      "raw": {
        "typeText": "Customizer",
        "nodeText": "export type Customizer = (\n  lens: CustomizerLens\n) => Utils.MaybePromise<Server | void>",
        "nodeFullText": "export type Customizer = (\n  lens: CustomizerLens\n) => Utils.MaybePromise<Server | void>"
      }
    },
    "(lib/utils/index).MaybePromise": {
      "kind": "alias",
      "name": "MaybePromise",
      "type": {
        "kind": "union",
        "isDiscriminated": false,
        "discriminantProperties": null,
        "raw": {
          "typeText": "MaybePromise<void | Server>",
          "nodeText": "export type MaybePromise<T = void> = T | Promise<T>",
          "nodeFullText": "export type MaybePromise<T = void> = T | Promise<T>"
        },
        "types": [
          {
            "kind": "primitive",
            "type": "void"
          },
          {
            "kind": "typeIndexRef",
            "link": "(framework/server).Server"
          },
          {
            "kind": "unsupported",
            "raw": {
              "typeText": "Promise<void | Server>",
              "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
              "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
            }
          }
        ]
      },
      "raw": {
        "typeText": "MaybePromise<void | Server>",
        "nodeText": "export type MaybePromise<T = void> = T | Promise<T>",
        "nodeFullText": "export type MaybePromise<T = void> = T | Promise<T>"
      }
    },
    "(framework/server).Server": {
      "kind": "interface",
      "name": "Server",
      "props": [
        {
          "kind": "prop",
          "name": "start",
          "type": {
            "kind": "callable",
            "isOverloaded": false,
            "hasProps": false,
            "props": [],
            "sigs": [
              {
                "kind": "sig",
                "return": {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "Promise<void>",
                    "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                    "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                  }
                },
                "params": []
              }
            ],
            "raw": {
              "typeText": "() => Promise<void>",
              "nodeText": "start(): Promise<void>",
              "nodeFullText": "/**\n   * Start the server instance\n   */\n  start(): Promise<void>"
            }
          }
        },
        {
          "kind": "prop",
          "name": "stop",
          "type": {
            "kind": "callable",
            "isOverloaded": false,
            "hasProps": false,
            "props": [],
            "sigs": [
              {
                "kind": "sig",
                "return": {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "Promise<void>",
                    "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                    "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                  }
                },
                "params": []
              }
            ],
            "raw": {
              "typeText": "() => Promise<void>",
              "nodeText": "stop(): Promise<void>",
              "nodeFullText": "/**\n   * Stop the server instance\n   */\n  stop(): Promise<void>"
            }
          }
        }
      ],
      "jsdoc": {
        "raw": "[API Reference](https://nexus-future.now.sh/#/references/api?id=server)  ⌁  [Guide](todo)\n\n### todo\n",
        "summary": "",
        "tags": []
      },
      "raw": {
        "typeText": "Server",
        "nodeText": "export interface Server {\n  /**\n   * Start the server instance\n   */\n  start(): Promise<void>\n  /**\n   * Stop the server instance\n   */\n  stop(): Promise<void>\n}",
        "nodeFullText": "/**\n * [API Reference](https://nexus-future.now.sh/#/references/api?id=server)  ⌁  [Guide](todo)\n *\n * ### todo\n *\n */\nexport interface Server {\n  /**\n   * Start the server instance\n   */\n  start(): Promise<void>\n  /**\n   * Stop the server instance\n   */\n  stop(): Promise<void>\n}"
      }
    },
    "(framework/server).CustomizerLens": {
      "kind": "interface",
      "name": "CustomizerLens",
      "props": [
        {
          "kind": "prop",
          "name": "schema",
          "type": {
            "kind": "unsupported",
            "raw": {
              "typeText": "GraphQLSchema",
              "nodeText": "export class GraphQLSchema {\n  extensions: Maybe<Readonly<Record<string, any>>>;\n  astNode: Maybe<SchemaDefinitionNode>;\n  extensionASTNodes: Maybe<ReadonlyArray<SchemaExtensionNode>>;\n\n  constructor(config: GraphQLSchemaConfig);\n\n  getQueryType(): Maybe<GraphQLObjectType>;\n  getMutationType(): Maybe<GraphQLObjectType>;\n  getSubscriptionType(): Maybe<GraphQLObjectType>;\n  getTypeMap(): TypeMap;\n  getType(name: string): Maybe<GraphQLNamedType>;\n  getPossibleTypes(\n    abstractType: GraphQLAbstractType,\n  ): ReadonlyArray<GraphQLObjectType>;\n\n  isPossibleType(\n    abstractType: GraphQLAbstractType,\n    possibleType: GraphQLObjectType,\n  ): boolean;\n\n  getDirectives(): ReadonlyArray<GraphQLDirective>;\n  getDirective(name: string): Maybe<GraphQLDirective>;\n\n  toConfig(): GraphQLSchemaConfig & {\n    types: GraphQLNamedType[];\n    directives: GraphQLDirective[];\n    extensions: Maybe<Readonly<Record<string, any>>>;\n    extensionASTNodes: ReadonlyArray<SchemaExtensionNode>;\n    assumeValid: boolean;\n    allowedLegacyNames: ReadonlyArray<string>;\n  };\n}",
              "nodeFullText": "/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\nexport class GraphQLSchema {\n  extensions: Maybe<Readonly<Record<string, any>>>;\n  astNode: Maybe<SchemaDefinitionNode>;\n  extensionASTNodes: Maybe<ReadonlyArray<SchemaExtensionNode>>;\n\n  constructor(config: GraphQLSchemaConfig);\n\n  getQueryType(): Maybe<GraphQLObjectType>;\n  getMutationType(): Maybe<GraphQLObjectType>;\n  getSubscriptionType(): Maybe<GraphQLObjectType>;\n  getTypeMap(): TypeMap;\n  getType(name: string): Maybe<GraphQLNamedType>;\n  getPossibleTypes(\n    abstractType: GraphQLAbstractType,\n  ): ReadonlyArray<GraphQLObjectType>;\n\n  isPossibleType(\n    abstractType: GraphQLAbstractType,\n    possibleType: GraphQLObjectType,\n  ): boolean;\n\n  getDirectives(): ReadonlyArray<GraphQLDirective>;\n  getDirective(name: string): Maybe<GraphQLDirective>;\n\n  toConfig(): GraphQLSchemaConfig & {\n    types: GraphQLNamedType[];\n    directives: GraphQLDirective[];\n    extensions: Maybe<Readonly<Record<string, any>>>;\n    extensionASTNodes: ReadonlyArray<SchemaExtensionNode>;\n    assumeValid: boolean;\n    allowedLegacyNames: ReadonlyArray<string>;\n  };\n}"
            }
          }
        },
        {
          "kind": "prop",
          "name": "express",
          "type": {
            "kind": "unsupported",
            "raw": {
              "typeText": "Express",
              "nodeText": "interface Express extends core.Express { }",
              "nodeFullText": "interface Express extends core.Express { }"
            }
          }
        },
        {
          "kind": "prop",
          "name": "context",
          "type": {
            "kind": "callable",
            "isOverloaded": false,
            "hasProps": false,
            "props": [],
            "sigs": [
              {
                "kind": "sig",
                "return": {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "Record<string, any>",
                    "nodeText": "type Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};",
                    "nodeFullText": "/**\r\n * Construct a type with a set of properties K of type T\r\n */\r\ntype Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};"
                  }
                },
                "params": [
                  {
                    "kind": "sigParam",
                    "name": "req",
                    "type": {
                      "kind": "unsupported",
                      "raw": {
                        "typeText": "Req",
                        "nodeText": "Req extends AnonymousRequest = AnonymousRequest",
                        "nodeFullText": "Req extends AnonymousRequest = AnonymousRequest"
                      }
                    }
                  }
                ]
              }
            ],
            "raw": {
              "typeText": "ContextCreator<Record<string, any>, Record<string, any>>",
              "nodeText": "interface ContextCreator<\n  Req extends AnonymousRequest = AnonymousRequest,\n  Context extends AnonymousContext = AnonymousContext\n> {\n  (req: Req): Context\n}",
              "nodeFullText": "interface ContextCreator<\n  Req extends AnonymousRequest = AnonymousRequest,\n  Context extends AnonymousContext = AnonymousContext\n> {\n  (req: Req): Context\n}"
            }
          }
        }
      ],
      "jsdoc": null,
      "raw": {
        "typeText": "CustomizerLens",
        "nodeText": "interface CustomizerLens {\n  /**\n   * The generated executable GraphQL Schema\n   */\n  schema: GraphQL.GraphQLSchema\n  /**\n   * The original Express server bundled with Nexus. Use it to add express middlewares or change its configuration in any way\n   */\n  express: Express\n  /**\n   * Function to add the generated context by Nexus to your custom server.\n   * /!\\ **If you need to add additional properties to your context, please use `schema.addToContext`**\n   */\n  context: ContextCreator\n}",
        "nodeFullText": "interface CustomizerLens {\n  /**\n   * The generated executable GraphQL Schema\n   */\n  schema: GraphQL.GraphQLSchema\n  /**\n   * The original Express server bundled with Nexus. Use it to add express middlewares or change its configuration in any way\n   */\n  express: Express\n  /**\n   * Function to add the generated context by Nexus to your custom server.\n   * /!\\ **If you need to add additional properties to your context, please use `schema.addToContext`**\n   */\n  context: ContextCreator\n}"
      }
    },
    "(framework/app).Settings": {
      "kind": "alias",
      "name": "Settings",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "original",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "Readonly<{ logger: Readonly<{ level: Level; pretty: Readonly<{ enabled: boolean; color: boolean; levelLabel: boolean; timeDiff: boolean; }>; output: Output; }>; schema: SettingsInput; server: Required<...>; }>",
                "nodeText": "type Readonly<T> = {\r\n    readonly [P in keyof T]: T[P];\r\n};",
                "nodeFullText": "/**\r\n * Make all properties in T readonly\r\n */\r\ntype Readonly<T> = {\r\n    readonly [P in keyof T]: T[P];\r\n};"
              }
            }
          },
          {
            "kind": "prop",
            "name": "current",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "Readonly<{ logger: Readonly<{ level: Level; pretty: Readonly<{ enabled: boolean; color: boolean; levelLabel: boolean; timeDiff: boolean; }>; output: Output; }>; schema: SettingsInput; server: Required<...>; }>",
                "nodeText": "type Readonly<T> = {\r\n    readonly [P in keyof T]: T[P];\r\n};",
                "nodeFullText": "/**\r\n * Make all properties in T readonly\r\n */\r\ntype Readonly<T> = {\r\n    readonly [P in keyof T]: T[P];\r\n};"
              }
            }
          },
          {
            "kind": "prop",
            "name": "change",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "primitive",
                    "type": "void"
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "newSetting",
                      "type": {
                        "kind": "typeIndexRef",
                        "link": "(framework/app).SettingsInput"
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(newSetting: SettingsInput) => void",
                "nodeText": "change(newSetting: SettingsInput): void",
                "nodeFullText": "/**\n   * todo\n   */\n  change(newSetting: SettingsInput): void"
              }
            }
          }
        ],
        "raw": {
          "typeText": "Settings",
          "nodeText": "export type Settings = {\n  /**\n   * todo\n   */\n  original: SettingsData\n  /**\n   * todo\n   */\n  current: SettingsData\n  /**\n   * todo\n   */\n  change(newSetting: SettingsInput): void\n}",
          "nodeFullText": "/**\n * todo\n */\nexport type Settings = {\n  /**\n   * todo\n   */\n  original: SettingsData\n  /**\n   * todo\n   */\n  current: SettingsData\n  /**\n   * todo\n   */\n  change(newSetting: SettingsInput): void\n}"
        }
      },
      "raw": {
        "typeText": "Settings",
        "nodeText": "export type Settings = {\n  /**\n   * todo\n   */\n  original: SettingsData\n  /**\n   * todo\n   */\n  current: SettingsData\n  /**\n   * todo\n   */\n  change(newSetting: SettingsInput): void\n}",
        "nodeFullText": "/**\n * todo\n */\nexport type Settings = {\n  /**\n   * todo\n   */\n  original: SettingsData\n  /**\n   * todo\n   */\n  current: SettingsData\n  /**\n   * todo\n   */\n  change(newSetting: SettingsInput): void\n}"
      }
    },
    "(framework/app).SettingsInput": {
      "kind": "alias",
      "name": "SettingsInput",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "logger",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "SettingsInput | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "alias",
                  "name": "SettingsInput",
                  "type": {
                    "kind": "typeIndexRef",
                    "link": "(lib/logger/root-logger).SettingsInput"
                  },
                  "raw": {
                    "typeText": "SettingsInput",
                    "nodeText": "export type SettingsInput = {\n  /**\n   * Set the level of this and all descedent loggers. This level setting has\n   * highest precedence of all logger level configuration tiers.\n   *\n   * The level config takes the first value found, searching tiers as follows:\n   *\n   *  1. logger instance setting\n   *  2. logger constructor setting\n   *  3. LOG_LEVEL environment variable setting\n   *  3. NODE_ENV=production -> info\n   *  4. otherwise -> debug\n   */\n  level?: Level.Level\n  /**\n   * Control pretty mode.\n   *\n   * Shorthands:\n   *\n   *  - `true` is shorthand for `{ enabled: true }`\n   *  - `false` is shorthand for `{ enabled: false }`\n   *\n   * When `undefined` pretty takes the first value found, in order:\n   *\n   *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n   *  2. `process.stdout.isTTY`\n   */\n  pretty?:\n    | boolean\n    | {\n        /**\n         * Disable or enable pretty mode.\n         *\n         * When `undefined` pretty takes the first value found, in order:\n         *\n         *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n         *  2. `process.stdout.isTTY`\n         */\n        enabled?: boolean\n        /**\n         * Should logs be colored?\n         *\n         * @default `true`\n         *\n         * Disabling can be useful when pretty logs are going to a destination that\n         * does not support rendering ANSI color codes (consequence being very\n         * difficult to read content).\n         */\n        color?: boolean\n        /**\n         * Should logs include the level label?\n         *\n         * @default `false`\n         *\n         * Enable this if understanding the level of a log is important to you\n         * and the icon+color system is insufficient for you to do so. Can be\n         * helpful for newcomers or a matter of taste for some.\n         */\n        levelLabel?: boolean\n        /**\n         * Should the logs include the time between it and previous log?\n         *\n         * @default `true`\n         */\n        timeDiff?: boolean\n      }\n}",
                    "nodeFullText": "export type SettingsInput = {\n  /**\n   * Set the level of this and all descedent loggers. This level setting has\n   * highest precedence of all logger level configuration tiers.\n   *\n   * The level config takes the first value found, searching tiers as follows:\n   *\n   *  1. logger instance setting\n   *  2. logger constructor setting\n   *  3. LOG_LEVEL environment variable setting\n   *  3. NODE_ENV=production -> info\n   *  4. otherwise -> debug\n   */\n  level?: Level.Level\n  /**\n   * Control pretty mode.\n   *\n   * Shorthands:\n   *\n   *  - `true` is shorthand for `{ enabled: true }`\n   *  - `false` is shorthand for `{ enabled: false }`\n   *\n   * When `undefined` pretty takes the first value found, in order:\n   *\n   *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n   *  2. `process.stdout.isTTY`\n   */\n  pretty?:\n    | boolean\n    | {\n        /**\n         * Disable or enable pretty mode.\n         *\n         * When `undefined` pretty takes the first value found, in order:\n         *\n         *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n         *  2. `process.stdout.isTTY`\n         */\n        enabled?: boolean\n        /**\n         * Should logs be colored?\n         *\n         * @default `true`\n         *\n         * Disabling can be useful when pretty logs are going to a destination that\n         * does not support rendering ANSI color codes (consequence being very\n         * difficult to read content).\n         */\n        color?: boolean\n        /**\n         * Should logs include the level label?\n         *\n         * @default `false`\n         *\n         * Enable this if understanding the level of a log is important to you\n         * and the icon+color system is insufficient for you to do so. Can be\n         * helpful for newcomers or a matter of taste for some.\n         */\n        levelLabel?: boolean\n        /**\n         * Should the logs include the time between it and previous log?\n         *\n         * @default `true`\n         */\n        timeDiff?: boolean\n      }\n}"
                  }
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "schema",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "SettingsInput | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "alias",
                  "name": "SettingsInput",
                  "type": {
                    "kind": "typeIndexRef",
                    "link": "(framework/schema/schema).SettingsInput"
                  },
                  "raw": {
                    "typeText": "SettingsInput",
                    "nodeText": "export type SettingsInput = {\n  /**\n   * todo\n   */\n  connections?: ConnectionConfig & {\n    // We tried the idea of types.default: false | ConnectionConfig\n    // but got blocked by https://github.com/microsoft/TypeScript/issues/17867\n\n    /**\n     * todo\n     *\n     * @default `false`\n     */\n    disableDefaultType?: boolean\n    /**\n     * todo\n     */\n    types?: {\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }\n  }\n}",
                    "nodeFullText": "export type SettingsInput = {\n  /**\n   * todo\n   */\n  connections?: ConnectionConfig & {\n    // We tried the idea of types.default: false | ConnectionConfig\n    // but got blocked by https://github.com/microsoft/TypeScript/issues/17867\n\n    /**\n     * todo\n     *\n     * @default `false`\n     */\n    disableDefaultType?: boolean\n    /**\n     * todo\n     */\n    types?: {\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }\n  }\n}"
                  }
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "server",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "ExtraSettingsInput | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "alias",
                  "name": "ExtraSettingsInput",
                  "type": {
                    "kind": "typeIndexRef",
                    "link": "(framework/server).ExtraSettingsInput"
                  },
                  "raw": {
                    "typeText": "ExtraSettingsInput",
                    "nodeText": "export type ExtraSettingsInput = {\n  /**\n   * todo\n   */\n  port?: number\n  /**\n   * todo\n   */\n  playground?: boolean\n  /**\n   * Create a message suitable for printing to the terminal about the server\n   * having been booted.\n   */\n  startMessage?: (address: { port: number; host: string; ip: string }) => void\n}",
                    "nodeFullText": "export type ExtraSettingsInput = {\n  /**\n   * todo\n   */\n  port?: number\n  /**\n   * todo\n   */\n  playground?: boolean\n  /**\n   * Create a message suitable for printing to the terminal about the server\n   * having been booted.\n   */\n  startMessage?: (address: { port: number; host: string; ip: string }) => void\n}"
                  }
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "SettingsInput",
          "nodeText": "type SettingsInput = {\n  logger?: Logger.SettingsInput\n  schema?: Schema.SettingsInput\n  server?: Server.ExtraSettingsInput\n}",
          "nodeFullText": "type SettingsInput = {\n  logger?: Logger.SettingsInput\n  schema?: Schema.SettingsInput\n  server?: Server.ExtraSettingsInput\n}"
        }
      },
      "raw": {
        "typeText": "SettingsInput",
        "nodeText": "type SettingsInput = {\n  logger?: Logger.SettingsInput\n  schema?: Schema.SettingsInput\n  server?: Server.ExtraSettingsInput\n}",
        "nodeFullText": "type SettingsInput = {\n  logger?: Logger.SettingsInput\n  schema?: Schema.SettingsInput\n  server?: Server.ExtraSettingsInput\n}"
      }
    },
    "(lib/logger/root-logger).SettingsInput": {
      "kind": "alias",
      "name": "SettingsInput",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "level",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "\"fatal\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\" | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "literal",
                  "name": "\"fatal\"",
                  "base": "string"
                },
                {
                  "kind": "literal",
                  "name": "\"error\"",
                  "base": "string"
                },
                {
                  "kind": "literal",
                  "name": "\"warn\"",
                  "base": "string"
                },
                {
                  "kind": "literal",
                  "name": "\"info\"",
                  "base": "string"
                },
                {
                  "kind": "literal",
                  "name": "\"debug\"",
                  "base": "string"
                },
                {
                  "kind": "literal",
                  "name": "\"trace\"",
                  "base": "string"
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "pretty",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "boolean | { enabled?: boolean | undefined; color?: boolean | undefined; levelLabel?: boolean | undefined; timeDiff?: boolean | undefined; } | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "literal",
                  "name": "false",
                  "base": "boolean"
                },
                {
                  "kind": "literal",
                  "name": "true",
                  "base": "boolean"
                },
                {
                  "kind": "object",
                  "props": [
                    {
                      "kind": "prop",
                      "name": "enabled",
                      "type": {
                        "kind": "union",
                        "isDiscriminated": false,
                        "discriminantProperties": null,
                        "raw": {
                          "typeText": "boolean | undefined",
                          "nodeFullText": "",
                          "nodeText": ""
                        },
                        "types": [
                          {
                            "kind": "primitive",
                            "type": "undefined"
                          },
                          {
                            "kind": "literal",
                            "name": "false",
                            "base": "boolean"
                          },
                          {
                            "kind": "literal",
                            "name": "true",
                            "base": "boolean"
                          }
                        ]
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "color",
                      "type": {
                        "kind": "union",
                        "isDiscriminated": false,
                        "discriminantProperties": null,
                        "raw": {
                          "typeText": "boolean | undefined",
                          "nodeFullText": "",
                          "nodeText": ""
                        },
                        "types": [
                          {
                            "kind": "primitive",
                            "type": "undefined"
                          },
                          {
                            "kind": "literal",
                            "name": "false",
                            "base": "boolean"
                          },
                          {
                            "kind": "literal",
                            "name": "true",
                            "base": "boolean"
                          }
                        ]
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "levelLabel",
                      "type": {
                        "kind": "union",
                        "isDiscriminated": false,
                        "discriminantProperties": null,
                        "raw": {
                          "typeText": "boolean | undefined",
                          "nodeFullText": "",
                          "nodeText": ""
                        },
                        "types": [
                          {
                            "kind": "primitive",
                            "type": "undefined"
                          },
                          {
                            "kind": "literal",
                            "name": "false",
                            "base": "boolean"
                          },
                          {
                            "kind": "literal",
                            "name": "true",
                            "base": "boolean"
                          }
                        ]
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "timeDiff",
                      "type": {
                        "kind": "union",
                        "isDiscriminated": false,
                        "discriminantProperties": null,
                        "raw": {
                          "typeText": "boolean | undefined",
                          "nodeFullText": "",
                          "nodeText": ""
                        },
                        "types": [
                          {
                            "kind": "primitive",
                            "type": "undefined"
                          },
                          {
                            "kind": "literal",
                            "name": "false",
                            "base": "boolean"
                          },
                          {
                            "kind": "literal",
                            "name": "true",
                            "base": "boolean"
                          }
                        ]
                      }
                    }
                  ],
                  "raw": {
                    "typeText": "{ enabled?: boolean | undefined; color?: boolean | undefined; levelLabel?: boolean | undefined; timeDiff?: boolean | undefined; }",
                    "nodeText": "{\n        /**\n         * Disable or enable pretty mode.\n         *\n         * When `undefined` pretty takes the first value found, in order:\n         *\n         *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n         *  2. `process.stdout.isTTY`\n         */\n        enabled?: boolean\n        /**\n         * Should logs be colored?\n         *\n         * @default `true`\n         *\n         * Disabling can be useful when pretty logs are going to a destination that\n         * does not support rendering ANSI color codes (consequence being very\n         * difficult to read content).\n         */\n        color?: boolean\n        /**\n         * Should logs include the level label?\n         *\n         * @default `false`\n         *\n         * Enable this if understanding the level of a log is important to you\n         * and the icon+color system is insufficient for you to do so. Can be\n         * helpful for newcomers or a matter of taste for some.\n         */\n        levelLabel?: boolean\n        /**\n         * Should the logs include the time between it and previous log?\n         *\n         * @default `true`\n         */\n        timeDiff?: boolean\n      }",
                    "nodeFullText": "{\n        /**\n         * Disable or enable pretty mode.\n         *\n         * When `undefined` pretty takes the first value found, in order:\n         *\n         *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n         *  2. `process.stdout.isTTY`\n         */\n        enabled?: boolean\n        /**\n         * Should logs be colored?\n         *\n         * @default `true`\n         *\n         * Disabling can be useful when pretty logs are going to a destination that\n         * does not support rendering ANSI color codes (consequence being very\n         * difficult to read content).\n         */\n        color?: boolean\n        /**\n         * Should logs include the level label?\n         *\n         * @default `false`\n         *\n         * Enable this if understanding the level of a log is important to you\n         * and the icon+color system is insufficient for you to do so. Can be\n         * helpful for newcomers or a matter of taste for some.\n         */\n        levelLabel?: boolean\n        /**\n         * Should the logs include the time between it and previous log?\n         *\n         * @default `true`\n         */\n        timeDiff?: boolean\n      }"
                  }
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "SettingsInput",
          "nodeText": "export type SettingsInput = {\n  /**\n   * Set the level of this and all descedent loggers. This level setting has\n   * highest precedence of all logger level configuration tiers.\n   *\n   * The level config takes the first value found, searching tiers as follows:\n   *\n   *  1. logger instance setting\n   *  2. logger constructor setting\n   *  3. LOG_LEVEL environment variable setting\n   *  3. NODE_ENV=production -> info\n   *  4. otherwise -> debug\n   */\n  level?: Level.Level\n  /**\n   * Control pretty mode.\n   *\n   * Shorthands:\n   *\n   *  - `true` is shorthand for `{ enabled: true }`\n   *  - `false` is shorthand for `{ enabled: false }`\n   *\n   * When `undefined` pretty takes the first value found, in order:\n   *\n   *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n   *  2. `process.stdout.isTTY`\n   */\n  pretty?:\n    | boolean\n    | {\n        /**\n         * Disable or enable pretty mode.\n         *\n         * When `undefined` pretty takes the first value found, in order:\n         *\n         *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n         *  2. `process.stdout.isTTY`\n         */\n        enabled?: boolean\n        /**\n         * Should logs be colored?\n         *\n         * @default `true`\n         *\n         * Disabling can be useful when pretty logs are going to a destination that\n         * does not support rendering ANSI color codes (consequence being very\n         * difficult to read content).\n         */\n        color?: boolean\n        /**\n         * Should logs include the level label?\n         *\n         * @default `false`\n         *\n         * Enable this if understanding the level of a log is important to you\n         * and the icon+color system is insufficient for you to do so. Can be\n         * helpful for newcomers or a matter of taste for some.\n         */\n        levelLabel?: boolean\n        /**\n         * Should the logs include the time between it and previous log?\n         *\n         * @default `true`\n         */\n        timeDiff?: boolean\n      }\n}",
          "nodeFullText": "export type SettingsInput = {\n  /**\n   * Set the level of this and all descedent loggers. This level setting has\n   * highest precedence of all logger level configuration tiers.\n   *\n   * The level config takes the first value found, searching tiers as follows:\n   *\n   *  1. logger instance setting\n   *  2. logger constructor setting\n   *  3. LOG_LEVEL environment variable setting\n   *  3. NODE_ENV=production -> info\n   *  4. otherwise -> debug\n   */\n  level?: Level.Level\n  /**\n   * Control pretty mode.\n   *\n   * Shorthands:\n   *\n   *  - `true` is shorthand for `{ enabled: true }`\n   *  - `false` is shorthand for `{ enabled: false }`\n   *\n   * When `undefined` pretty takes the first value found, in order:\n   *\n   *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n   *  2. `process.stdout.isTTY`\n   */\n  pretty?:\n    | boolean\n    | {\n        /**\n         * Disable or enable pretty mode.\n         *\n         * When `undefined` pretty takes the first value found, in order:\n         *\n         *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n         *  2. `process.stdout.isTTY`\n         */\n        enabled?: boolean\n        /**\n         * Should logs be colored?\n         *\n         * @default `true`\n         *\n         * Disabling can be useful when pretty logs are going to a destination that\n         * does not support rendering ANSI color codes (consequence being very\n         * difficult to read content).\n         */\n        color?: boolean\n        /**\n         * Should logs include the level label?\n         *\n         * @default `false`\n         *\n         * Enable this if understanding the level of a log is important to you\n         * and the icon+color system is insufficient for you to do so. Can be\n         * helpful for newcomers or a matter of taste for some.\n         */\n        levelLabel?: boolean\n        /**\n         * Should the logs include the time between it and previous log?\n         *\n         * @default `true`\n         */\n        timeDiff?: boolean\n      }\n}"
        }
      },
      "raw": {
        "typeText": "SettingsInput",
        "nodeText": "export type SettingsInput = {\n  /**\n   * Set the level of this and all descedent loggers. This level setting has\n   * highest precedence of all logger level configuration tiers.\n   *\n   * The level config takes the first value found, searching tiers as follows:\n   *\n   *  1. logger instance setting\n   *  2. logger constructor setting\n   *  3. LOG_LEVEL environment variable setting\n   *  3. NODE_ENV=production -> info\n   *  4. otherwise -> debug\n   */\n  level?: Level.Level\n  /**\n   * Control pretty mode.\n   *\n   * Shorthands:\n   *\n   *  - `true` is shorthand for `{ enabled: true }`\n   *  - `false` is shorthand for `{ enabled: false }`\n   *\n   * When `undefined` pretty takes the first value found, in order:\n   *\n   *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n   *  2. `process.stdout.isTTY`\n   */\n  pretty?:\n    | boolean\n    | {\n        /**\n         * Disable or enable pretty mode.\n         *\n         * When `undefined` pretty takes the first value found, in order:\n         *\n         *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n         *  2. `process.stdout.isTTY`\n         */\n        enabled?: boolean\n        /**\n         * Should logs be colored?\n         *\n         * @default `true`\n         *\n         * Disabling can be useful when pretty logs are going to a destination that\n         * does not support rendering ANSI color codes (consequence being very\n         * difficult to read content).\n         */\n        color?: boolean\n        /**\n         * Should logs include the level label?\n         *\n         * @default `false`\n         *\n         * Enable this if understanding the level of a log is important to you\n         * and the icon+color system is insufficient for you to do so. Can be\n         * helpful for newcomers or a matter of taste for some.\n         */\n        levelLabel?: boolean\n        /**\n         * Should the logs include the time between it and previous log?\n         *\n         * @default `true`\n         */\n        timeDiff?: boolean\n      }\n}",
        "nodeFullText": "export type SettingsInput = {\n  /**\n   * Set the level of this and all descedent loggers. This level setting has\n   * highest precedence of all logger level configuration tiers.\n   *\n   * The level config takes the first value found, searching tiers as follows:\n   *\n   *  1. logger instance setting\n   *  2. logger constructor setting\n   *  3. LOG_LEVEL environment variable setting\n   *  3. NODE_ENV=production -> info\n   *  4. otherwise -> debug\n   */\n  level?: Level.Level\n  /**\n   * Control pretty mode.\n   *\n   * Shorthands:\n   *\n   *  - `true` is shorthand for `{ enabled: true }`\n   *  - `false` is shorthand for `{ enabled: false }`\n   *\n   * When `undefined` pretty takes the first value found, in order:\n   *\n   *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n   *  2. `process.stdout.isTTY`\n   */\n  pretty?:\n    | boolean\n    | {\n        /**\n         * Disable or enable pretty mode.\n         *\n         * When `undefined` pretty takes the first value found, in order:\n         *\n         *  1. `process.env.LOG_PRETTY` (admits case insensitive: `true` | `false`)\n         *  2. `process.stdout.isTTY`\n         */\n        enabled?: boolean\n        /**\n         * Should logs be colored?\n         *\n         * @default `true`\n         *\n         * Disabling can be useful when pretty logs are going to a destination that\n         * does not support rendering ANSI color codes (consequence being very\n         * difficult to read content).\n         */\n        color?: boolean\n        /**\n         * Should logs include the level label?\n         *\n         * @default `false`\n         *\n         * Enable this if understanding the level of a log is important to you\n         * and the icon+color system is insufficient for you to do so. Can be\n         * helpful for newcomers or a matter of taste for some.\n         */\n        levelLabel?: boolean\n        /**\n         * Should the logs include the time between it and previous log?\n         *\n         * @default `true`\n         */\n        timeDiff?: boolean\n      }\n}"
      }
    },
    "(framework/schema/schema).SettingsInput": {
      "kind": "alias",
      "name": "SettingsInput",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "connections",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "(Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | \"disableBackwardPagination\" | \"validateArgs\" | ... 7 more ... | \"typePrefix\"> & { ...; }) | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "intersection",
                  "raw": {
                    "typeText": "Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | \"disableBackwardPagination\" | \"validateArgs\" | ... 7 more ... | \"typePrefix\"> & { ...; }",
                    "nodeFullText": "",
                    "nodeText": ""
                  },
                  "types": [
                    {
                      "kind": "unsupported",
                      "raw": {
                        "typeText": "Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | \"disableBackwardPagination\" | \"validateArgs\" | ... 7 more ... | \"typePrefix\">",
                        "nodeText": "type Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};",
                        "nodeFullText": "/**\r\n * From T, pick a set of properties whose keys are in the union K\r\n */\r\ntype Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};"
                      }
                    },
                    {
                      "kind": "object",
                      "props": [
                        {
                          "kind": "prop",
                          "name": "disableDefaultType",
                          "type": {
                            "kind": "union",
                            "isDiscriminated": false,
                            "discriminantProperties": null,
                            "raw": {
                              "typeText": "boolean | undefined",
                              "nodeFullText": "",
                              "nodeText": ""
                            },
                            "types": [
                              {
                                "kind": "primitive",
                                "type": "undefined"
                              },
                              {
                                "kind": "literal",
                                "name": "false",
                                "base": "boolean"
                              },
                              {
                                "kind": "literal",
                                "name": "true",
                                "base": "boolean"
                              }
                            ]
                          }
                        },
                        {
                          "kind": "prop",
                          "name": "types",
                          "type": {
                            "kind": "union",
                            "isDiscriminated": false,
                            "discriminantProperties": null,
                            "raw": {
                              "typeText": "{ [typeName: string]: Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | \"disableBackwardPagination\" | \"validateArgs\" | ... 7 more ... | \"typePrefix\"> | undefined; default?: Pick<...> | undefined; } | undefined",
                              "nodeFullText": "",
                              "nodeText": ""
                            },
                            "types": [
                              {
                                "kind": "primitive",
                                "type": "undefined"
                              },
                              {
                                "kind": "object",
                                "props": [
                                  {
                                    "kind": "prop",
                                    "name": "default",
                                    "type": {
                                      "kind": "union",
                                      "isDiscriminated": false,
                                      "discriminantProperties": null,
                                      "raw": {
                                        "typeText": "Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | \"disableBackwardPagination\" | \"validateArgs\" | ... 7 more ... | \"typePrefix\"> | undefined",
                                        "nodeFullText": "",
                                        "nodeText": ""
                                      },
                                      "types": [
                                        {
                                          "kind": "primitive",
                                          "type": "undefined"
                                        },
                                        {
                                          "kind": "alias",
                                          "name": "Pick",
                                          "type": {
                                            "kind": "unsupported",
                                            "raw": {
                                              "typeText": "Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | \"disableBackwardPagination\" | \"validateArgs\" | ... 7 more ... | \"typePrefix\">",
                                              "nodeText": "type Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};",
                                              "nodeFullText": "/**\r\n * From T, pick a set of properties whose keys are in the union K\r\n */\r\ntype Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};"
                                            }
                                          },
                                          "raw": {
                                            "typeText": "Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | \"disableBackwardPagination\" | \"validateArgs\" | ... 7 more ... | \"typePrefix\">",
                                            "nodeText": "type Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};",
                                            "nodeFullText": "/**\r\n * From T, pick a set of properties whose keys are in the union K\r\n */\r\ntype Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ],
                                "raw": {
                                  "typeText": "{ [typeName: string]: Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | \"disableBackwardPagination\" | \"validateArgs\" | ... 7 more ... | \"typePrefix\"> | undefined; default?: Pick<...> | undefined; }",
                                  "nodeText": "{\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }",
                                  "nodeFullText": "{\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }"
                                }
                              }
                            ]
                          }
                        }
                      ],
                      "raw": {
                        "typeText": "{ disableDefaultType?: boolean | undefined; types?: { [typeName: string]: Pick<ConnectionPluginConfig, \"includeNodesField\" | \"additionalArgs\" | \"disableForwardPagination\" | ... 9 more ... | \"typePrefix\"> | undefined; default?: Pick<...> | undefined; } | undefined; }",
                        "nodeText": "{\n    // We tried the idea of types.default: false | ConnectionConfig\n    // but got blocked by https://github.com/microsoft/TypeScript/issues/17867\n\n    /**\n     * todo\n     *\n     * @default `false`\n     */\n    disableDefaultType?: boolean\n    /**\n     * todo\n     */\n    types?: {\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }\n  }",
                        "nodeFullText": "{\n    // We tried the idea of types.default: false | ConnectionConfig\n    // but got blocked by https://github.com/microsoft/TypeScript/issues/17867\n\n    /**\n     * todo\n     *\n     * @default `false`\n     */\n    disableDefaultType?: boolean\n    /**\n     * todo\n     */\n    types?: {\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }\n  }"
                      }
                    }
                  ]
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "SettingsInput",
          "nodeText": "export type SettingsInput = {\n  /**\n   * todo\n   */\n  connections?: ConnectionConfig & {\n    // We tried the idea of types.default: false | ConnectionConfig\n    // but got blocked by https://github.com/microsoft/TypeScript/issues/17867\n\n    /**\n     * todo\n     *\n     * @default `false`\n     */\n    disableDefaultType?: boolean\n    /**\n     * todo\n     */\n    types?: {\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }\n  }\n}",
          "nodeFullText": "export type SettingsInput = {\n  /**\n   * todo\n   */\n  connections?: ConnectionConfig & {\n    // We tried the idea of types.default: false | ConnectionConfig\n    // but got blocked by https://github.com/microsoft/TypeScript/issues/17867\n\n    /**\n     * todo\n     *\n     * @default `false`\n     */\n    disableDefaultType?: boolean\n    /**\n     * todo\n     */\n    types?: {\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }\n  }\n}"
        }
      },
      "raw": {
        "typeText": "SettingsInput",
        "nodeText": "export type SettingsInput = {\n  /**\n   * todo\n   */\n  connections?: ConnectionConfig & {\n    // We tried the idea of types.default: false | ConnectionConfig\n    // but got blocked by https://github.com/microsoft/TypeScript/issues/17867\n\n    /**\n     * todo\n     *\n     * @default `false`\n     */\n    disableDefaultType?: boolean\n    /**\n     * todo\n     */\n    types?: {\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }\n  }\n}",
        "nodeFullText": "export type SettingsInput = {\n  /**\n   * todo\n   */\n  connections?: ConnectionConfig & {\n    // We tried the idea of types.default: false | ConnectionConfig\n    // but got blocked by https://github.com/microsoft/TypeScript/issues/17867\n\n    /**\n     * todo\n     *\n     * @default `false`\n     */\n    disableDefaultType?: boolean\n    /**\n     * todo\n     */\n    types?: {\n      default?: ConnectionConfig\n      // Extra undefined below is forced by it being above, forced via `?:`.\n      // This is a TS limitation, cannot express void vs missing semantics,\n      // being tracked here: https://github.com/microsoft/TypeScript/issues/13195\n      [typeName: string]: ConnectionConfig | undefined\n    }\n  }\n}"
      }
    },
    "(framework/server).ExtraSettingsInput": {
      "kind": "alias",
      "name": "ExtraSettingsInput",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "port",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "number | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "primitive",
                  "type": "number"
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "playground",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "boolean | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "literal",
                  "name": "false",
                  "base": "boolean"
                },
                {
                  "kind": "literal",
                  "name": "true",
                  "base": "boolean"
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "startMessage",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "((address: { port: number; host: string; ip: string; }) => void) | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "callable",
                  "isOverloaded": false,
                  "hasProps": false,
                  "props": [],
                  "sigs": [
                    {
                      "kind": "sig",
                      "return": {
                        "kind": "primitive",
                        "type": "void"
                      },
                      "params": [
                        {
                          "kind": "sigParam",
                          "name": "address",
                          "type": {
                            "kind": "object",
                            "props": [
                              {
                                "kind": "prop",
                                "name": "port",
                                "type": {
                                  "kind": "primitive",
                                  "type": "number"
                                }
                              },
                              {
                                "kind": "prop",
                                "name": "host",
                                "type": {
                                  "kind": "primitive",
                                  "type": "string"
                                }
                              },
                              {
                                "kind": "prop",
                                "name": "ip",
                                "type": {
                                  "kind": "primitive",
                                  "type": "string"
                                }
                              }
                            ],
                            "raw": {
                              "typeText": "{ port: number; host: string; ip: string; }",
                              "nodeText": "{ port: number; host: string; ip: string }",
                              "nodeFullText": "{ port: number; host: string; ip: string }"
                            }
                          }
                        }
                      ]
                    }
                  ],
                  "raw": {
                    "typeText": "(address: { port: number; host: string; ip: string; }) => void",
                    "nodeText": "(address: { port: number; host: string; ip: string }) => void",
                    "nodeFullText": "(address: { port: number; host: string; ip: string }) => void"
                  }
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "ExtraSettingsInput",
          "nodeText": "export type ExtraSettingsInput = {\n  /**\n   * todo\n   */\n  port?: number\n  /**\n   * todo\n   */\n  playground?: boolean\n  /**\n   * Create a message suitable for printing to the terminal about the server\n   * having been booted.\n   */\n  startMessage?: (address: { port: number; host: string; ip: string }) => void\n}",
          "nodeFullText": "export type ExtraSettingsInput = {\n  /**\n   * todo\n   */\n  port?: number\n  /**\n   * todo\n   */\n  playground?: boolean\n  /**\n   * Create a message suitable for printing to the terminal about the server\n   * having been booted.\n   */\n  startMessage?: (address: { port: number; host: string; ip: string }) => void\n}"
        }
      },
      "raw": {
        "typeText": "ExtraSettingsInput",
        "nodeText": "export type ExtraSettingsInput = {\n  /**\n   * todo\n   */\n  port?: number\n  /**\n   * todo\n   */\n  playground?: boolean\n  /**\n   * Create a message suitable for printing to the terminal about the server\n   * having been booted.\n   */\n  startMessage?: (address: { port: number; host: string; ip: string }) => void\n}",
        "nodeFullText": "export type ExtraSettingsInput = {\n  /**\n   * todo\n   */\n  port?: number\n  /**\n   * todo\n   */\n  playground?: boolean\n  /**\n   * Create a message suitable for printing to the terminal about the server\n   * having been booted.\n   */\n  startMessage?: (address: { port: number; host: string; ip: string }) => void\n}"
      }
    },
    "(framework/schema/schema).Schema": {
      "kind": "alias",
      "name": "Schema",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "queryType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "(config: Pick<NexusObjectTypeConfig<\"Query\">, \"description\" | \"definition\" | \"nonNullDefaults\" | \"rootTyping\">) => NexusObjectTypeDef<\"Query\">",
                "nodeText": "export declare function queryType(config: Omit<NexusObjectTypeConfig<\"Query\">, \"name\">): NexusObjectTypeDef<\"Query\">;",
                "nodeFullText": "export declare function queryType(config: Omit<NexusObjectTypeConfig<\"Query\">, \"name\">): NexusObjectTypeDef<\"Query\">;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "mutationType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "(config: Pick<NexusObjectTypeConfig<\"Mutation\">, \"description\" | \"definition\" | \"nonNullDefaults\" | \"rootTyping\">) => NexusObjectTypeDef<\"Mutation\">",
                "nodeText": "export declare function mutationType(config: Omit<NexusObjectTypeConfig<\"Mutation\">, \"name\">): NexusObjectTypeDef<\"Mutation\">;",
                "nodeFullText": "export declare function mutationType(config: Omit<NexusObjectTypeConfig<\"Mutation\">, \"name\">): NexusObjectTypeDef<\"Mutation\">;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "objectType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<TypeName extends string>(config: NexusObjectTypeConfig<TypeName>) => NexusObjectTypeDef<TypeName>",
                "nodeText": "export declare function objectType<TypeName extends string>(config: NexusObjectTypeConfig<TypeName>): NexusObjectTypeDef<TypeName>;",
                "nodeFullText": "export declare function objectType<TypeName extends string>(config: NexusObjectTypeConfig<TypeName>): NexusObjectTypeDef<TypeName>;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "inputObjectType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<TypeName extends string>(config: NexusInputObjectTypeConfig<TypeName>) => NexusInputObjectTypeDef<TypeName>",
                "nodeText": "export declare function inputObjectType<TypeName extends string>(config: NexusInputObjectTypeConfig<TypeName>): NexusInputObjectTypeDef<TypeName>;",
                "nodeFullText": "export declare function inputObjectType<TypeName extends string>(config: NexusInputObjectTypeConfig<TypeName>): NexusInputObjectTypeDef<TypeName>;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "enumType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<TypeName extends string>(config: EnumTypeConfig<TypeName>) => NexusEnumTypeDef<TypeName>",
                "nodeText": "export declare function enumType<TypeName extends string>(config: EnumTypeConfig<TypeName>): NexusEnumTypeDef<TypeName>;",
                "nodeFullText": "export declare function enumType<TypeName extends string>(config: EnumTypeConfig<TypeName>): NexusEnumTypeDef<TypeName>;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "scalarType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<TypeName extends string>(options: NexusScalarTypeConfig<TypeName>) => NexusScalarTypeDef<TypeName>",
                "nodeText": "export declare function scalarType<TypeName extends string>(options: NexusScalarTypeConfig<TypeName>): NexusScalarTypeDef<TypeName>;",
                "nodeFullText": "export declare function scalarType<TypeName extends string>(options: NexusScalarTypeConfig<TypeName>): NexusScalarTypeDef<TypeName>;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "unionType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<TypeName extends string>(config: NexusUnionTypeConfig<TypeName>) => NexusUnionTypeDef<TypeName>",
                "nodeText": "export declare function unionType<TypeName extends string>(config: NexusUnionTypeConfig<TypeName>): NexusUnionTypeDef<TypeName>;",
                "nodeFullText": "/**\n * Defines a new `GraphQLUnionType`\n * @param config\n */\nexport declare function unionType<TypeName extends string>(config: NexusUnionTypeConfig<TypeName>): NexusUnionTypeDef<TypeName>;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "interfaceType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<TypeName extends string>(config: NexusInterfaceTypeConfig<TypeName>) => NexusInterfaceTypeDef<TypeName>",
                "nodeText": "export declare function interfaceType<TypeName extends string>(config: NexusInterfaceTypeConfig<TypeName>): NexusInterfaceTypeDef<TypeName>;",
                "nodeFullText": "/**\n * Defines a GraphQLInterfaceType\n * @param config\n */\nexport declare function interfaceType<TypeName extends string>(config: NexusInterfaceTypeConfig<TypeName>): NexusInterfaceTypeDef<TypeName>;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "arg",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<T extends string>(options: { type: NexusArgConfigType<T>; } & NexusArgConfig<T>) => NexusArgDef<T>",
                "nodeText": "export declare function arg<T extends AllInputTypes>(options: {\n    type: NexusArgConfigType<T>;\n} & NexusArgConfig<T>): NexusArgDef<T>;",
                "nodeFullText": "/**\n * Defines an argument that can be used in any object or interface type\n *\n * Takes the GraphQL type name and any options.\n *\n * The value returned from this argument can be used multiple times in any valid `args` object value\n *\n * @see https://graphql.github.io/learn/schema/#arguments\n */\nexport declare function arg<T extends AllInputTypes>(options: {\n    type: NexusArgConfigType<T>;\n} & NexusArgConfig<T>): NexusArgDef<T>;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "intArg",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "(options?: ScalarArgConfig<number> | undefined) => NexusArgDef<\"Int\">",
                "nodeText": "export declare function intArg(options?: ScalarArgConfig<number>): NexusArgDef<\"Int\">;",
                "nodeFullText": "export declare function intArg(options?: ScalarArgConfig<number>): NexusArgDef<\"Int\">;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "stringArg",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "(options?: ScalarArgConfig<string> | undefined) => NexusArgDef<\"String\">",
                "nodeText": "export declare function stringArg(options?: ScalarArgConfig<string>): NexusArgDef<\"String\">;",
                "nodeFullText": "export declare function stringArg(options?: ScalarArgConfig<string>): NexusArgDef<\"String\">;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "booleanArg",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "(options?: ScalarArgConfig<boolean> | undefined) => NexusArgDef<\"Boolean\">",
                "nodeText": "export declare function booleanArg(options?: ScalarArgConfig<boolean>): NexusArgDef<\"Boolean\">;",
                "nodeFullText": "export declare function booleanArg(options?: ScalarArgConfig<boolean>): NexusArgDef<\"Boolean\">;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "floatArg",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "(options?: ScalarArgConfig<number> | undefined) => NexusArgDef<\"Float\">",
                "nodeText": "export declare function floatArg(options?: ScalarArgConfig<number>): NexusArgDef<\"Float\">;",
                "nodeFullText": "export declare function floatArg(options?: ScalarArgConfig<number>): NexusArgDef<\"Float\">;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "idArg",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "(options?: ScalarArgConfig<string> | undefined) => NexusArgDef<\"ID\">",
                "nodeText": "export declare function idArg(options?: ScalarArgConfig<string>): NexusArgDef<\"ID\">;",
                "nodeFullText": "export declare function idArg(options?: ScalarArgConfig<string>): NexusArgDef<\"ID\">;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "extendType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<TypeName extends string>(config: NexusExtendTypeConfig<TypeName>) => NexusExtendTypeDef<TypeName>",
                "nodeText": "export declare function extendType<TypeName extends AllOutputTypesPossible>(config: NexusExtendTypeConfig<TypeName>): NexusExtendTypeDef<TypeName>;",
                "nodeFullText": "/**\n * Adds new fields to an existing objectType in the schema. Useful when\n * splitting your schema across several domains.\n *\n * @see http://graphql-nexus.com/api/extendType\n */\nexport declare function extendType<TypeName extends AllOutputTypesPossible>(config: NexusExtendTypeConfig<TypeName>): NexusExtendTypeDef<TypeName>;"
              }
            }
          },
          {
            "kind": "prop",
            "name": "extendInputType",
            "type": {
              "kind": "unsupported",
              "raw": {
                "typeText": "<TypeName extends string>(config: NexusExtendInputTypeConfig<TypeName>) => NexusExtendInputTypeDef<TypeName>",
                "nodeText": "export declare function extendInputType<TypeName extends GetGen<\"inputNames\", string>>(config: NexusExtendInputTypeConfig<TypeName>): NexusExtendInputTypeDef<TypeName>;",
                "nodeFullText": "/**\n * Adds new fields to an existing inputObjectType in the schema. Useful when\n * splitting your schema across several domains.\n *\n * @see http://graphql-nexus.com/api/extendType\n */\nexport declare function extendInputType<TypeName extends GetGen<\"inputNames\", string>>(config: NexusExtendInputTypeConfig<TypeName>): NexusExtendInputTypeDef<TypeName>;"
              }
            }
          }
        ],
        "raw": {
          "typeText": "Schema",
          "nodeText": "export type Schema = {\n  // addToContext: <T extends {}>(\n  //   contextContributor: ContextContributor<T>\n  // ) => App\n  queryType: typeof NexusSchema.queryType\n  mutationType: typeof NexusSchema.mutationType\n  objectType: typeof NexusSchema.objectType\n  inputObjectType: typeof NexusSchema.inputObjectType\n  enumType: typeof NexusSchema.enumType\n  scalarType: typeof NexusSchema.scalarType\n  unionType: typeof NexusSchema.unionType\n  interfaceType: typeof NexusSchema.interfaceType\n  arg: typeof NexusSchema.arg\n  intArg: typeof NexusSchema.intArg\n  stringArg: typeof NexusSchema.stringArg\n  booleanArg: typeof NexusSchema.booleanArg\n  floatArg: typeof NexusSchema.floatArg\n  idArg: typeof NexusSchema.idArg\n  extendType: typeof NexusSchema.extendType\n  extendInputType: typeof NexusSchema.extendInputType\n}",
          "nodeFullText": "export type Schema = {\n  // addToContext: <T extends {}>(\n  //   contextContributor: ContextContributor<T>\n  // ) => App\n  queryType: typeof NexusSchema.queryType\n  mutationType: typeof NexusSchema.mutationType\n  objectType: typeof NexusSchema.objectType\n  inputObjectType: typeof NexusSchema.inputObjectType\n  enumType: typeof NexusSchema.enumType\n  scalarType: typeof NexusSchema.scalarType\n  unionType: typeof NexusSchema.unionType\n  interfaceType: typeof NexusSchema.interfaceType\n  arg: typeof NexusSchema.arg\n  intArg: typeof NexusSchema.intArg\n  stringArg: typeof NexusSchema.stringArg\n  booleanArg: typeof NexusSchema.booleanArg\n  floatArg: typeof NexusSchema.floatArg\n  idArg: typeof NexusSchema.idArg\n  extendType: typeof NexusSchema.extendType\n  extendInputType: typeof NexusSchema.extendInputType\n}"
        }
      },
      "raw": {
        "typeText": "Schema",
        "nodeText": "export type Schema = {\n  // addToContext: <T extends {}>(\n  //   contextContributor: ContextContributor<T>\n  // ) => App\n  queryType: typeof NexusSchema.queryType\n  mutationType: typeof NexusSchema.mutationType\n  objectType: typeof NexusSchema.objectType\n  inputObjectType: typeof NexusSchema.inputObjectType\n  enumType: typeof NexusSchema.enumType\n  scalarType: typeof NexusSchema.scalarType\n  unionType: typeof NexusSchema.unionType\n  interfaceType: typeof NexusSchema.interfaceType\n  arg: typeof NexusSchema.arg\n  intArg: typeof NexusSchema.intArg\n  stringArg: typeof NexusSchema.stringArg\n  booleanArg: typeof NexusSchema.booleanArg\n  floatArg: typeof NexusSchema.floatArg\n  idArg: typeof NexusSchema.idArg\n  extendType: typeof NexusSchema.extendType\n  extendInputType: typeof NexusSchema.extendInputType\n}",
        "nodeFullText": "export type Schema = {\n  // addToContext: <T extends {}>(\n  //   contextContributor: ContextContributor<T>\n  // ) => App\n  queryType: typeof NexusSchema.queryType\n  mutationType: typeof NexusSchema.mutationType\n  objectType: typeof NexusSchema.objectType\n  inputObjectType: typeof NexusSchema.inputObjectType\n  enumType: typeof NexusSchema.enumType\n  scalarType: typeof NexusSchema.scalarType\n  unionType: typeof NexusSchema.unionType\n  interfaceType: typeof NexusSchema.interfaceType\n  arg: typeof NexusSchema.arg\n  intArg: typeof NexusSchema.intArg\n  stringArg: typeof NexusSchema.stringArg\n  booleanArg: typeof NexusSchema.booleanArg\n  floatArg: typeof NexusSchema.floatArg\n  idArg: typeof NexusSchema.idArg\n  extendType: typeof NexusSchema.extendType\n  extendInputType: typeof NexusSchema.extendInputType\n}"
      }
    },
    "(framework/app).ContextContributor": {
      "kind": "alias",
      "name": "ContextContributor",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "unsupported",
              "raw": {
                "typeText": "T",
                "nodeText": "T extends {} = any",
                "nodeFullText": "T extends {} = any"
              }
            },
            "params": [
              {
                "kind": "sigParam",
                "name": "req",
                "type": {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "Req",
                    "nodeText": "Req",
                    "nodeFullText": "Req"
                  }
                }
              }
            ]
          }
        ],
        "raw": {
          "typeText": "ContextContributor<Req, T>",
          "nodeText": "type ContextContributor<Req, T extends {} = any> = (req: Req) => T",
          "nodeFullText": "// todo the jsdoc below is lost on the destructured object exports later on...\n// todo plugins could augment the request\n// plugins will be able to use typegen to signal this fact\n// all places in the framework where the req object is referenced should be\n// actually referencing the typegen version, so that it reflects the req +\n// plugin augmentations type\ntype ContextContributor<Req, T extends {} = any> = (req: Req) => T"
        }
      },
      "raw": {
        "typeText": "ContextContributor<Req, T>",
        "nodeText": "type ContextContributor<Req, T extends {} = any> = (req: Req) => T",
        "nodeFullText": "// todo the jsdoc below is lost on the destructured object exports later on...\n// todo plugins could augment the request\n// plugins will be able to use typegen to signal this fact\n// all places in the framework where the req object is referenced should be\n// actually referencing the typegen version, so that it reflects the req +\n// plugin augmentations type\ntype ContextContributor<Req, T extends {} = any> = (req: Req) => T"
      }
    },
    "(framework/testing).TestContext": {
      "kind": "alias",
      "name": "TestContext",
      "raw": {
        "nodeFullText": "\n\nexport type TestContext = nexusFutureTestContextRoot",
        "nodeText": "export type TestContext = nexusFutureTestContextRoot",
        "typeText": "nexusFutureTestContextRoot"
      },
      "type": {
        "kind": "typeIndexRef",
        "link": "(framework/testing).nexusFutureTestContextRoot"
      }
    },
    "(framework/testing).nexusFutureTestContextRoot": {
      "kind": "interface",
      "name": "nexusFutureTestContextRoot",
      "props": [
        {
          "kind": "prop",
          "name": "app",
          "type": {
            "kind": "typeIndexRef",
            "link": "(framework/testing).nexusFutureTestContextApp"
          }
        }
      ],
      "jsdoc": null,
      "raw": {
        "typeText": "nexusFutureTestContextRoot",
        "nodeText": "interface nexusFutureTestContextRoot {\n    app: nexusFutureTestContextApp\n  }",
        "nodeFullText": "interface nexusFutureTestContextRoot {\n    app: nexusFutureTestContextApp\n  }"
      }
    },
    "(framework/testing).nexusFutureTestContextApp": {
      "kind": "interface",
      "name": "nexusFutureTestContextApp",
      "props": [
        {
          "kind": "prop",
          "name": "query",
          "type": {
            "kind": "unsupported",
            "raw": {
              "typeText": "<T extends any>(query: string, variables?: Variables | undefined) => Promise<T>",
              "nodeText": "request<T extends any>(query: string, variables?: Variables): Promise<T>;",
              "nodeFullText": "request<T extends any>(query: string, variables?: Variables): Promise<T>;"
            }
          }
        },
        {
          "kind": "prop",
          "name": "server",
          "type": {
            "kind": "object",
            "props": [
              {
                "kind": "prop",
                "name": "start",
                "type": {
                  "kind": "callable",
                  "isOverloaded": false,
                  "hasProps": false,
                  "props": [],
                  "sigs": [
                    {
                      "kind": "sig",
                      "return": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Promise<void>",
                          "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                          "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                        }
                      },
                      "params": []
                    }
                  ],
                  "raw": {
                    "typeText": "() => Promise<void>",
                    "nodeText": "() => Promise<void>",
                    "nodeFullText": "() => Promise<void>"
                  }
                }
              },
              {
                "kind": "prop",
                "name": "stop",
                "type": {
                  "kind": "callable",
                  "isOverloaded": false,
                  "hasProps": false,
                  "props": [],
                  "sigs": [
                    {
                      "kind": "sig",
                      "return": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Promise<void>",
                          "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                          "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                        }
                      },
                      "params": []
                    }
                  ],
                  "raw": {
                    "typeText": "() => Promise<void>",
                    "nodeText": "() => Promise<void>",
                    "nodeFullText": "() => Promise<void>"
                  }
                }
              }
            ],
            "raw": {
              "typeText": "{ start: () => Promise<void>; stop: () => Promise<void>; }",
              "nodeText": "{\n    start: () => Promise<void>\n    stop: () => Promise<void>\n  }",
              "nodeFullText": "{\n    start: () => Promise<void>\n    stop: () => Promise<void>\n  }"
            }
          }
        }
      ],
      "jsdoc": null,
      "raw": {
        "typeText": "nexusFutureTestContextApp",
        "nodeText": "interface nexusFutureTestContextApp extends TestContextAppCore {}",
        "nodeFullText": "interface nexusFutureTestContextApp extends TestContextAppCore {}"
      }
    },
    "(core/plugin/index).DriverCreator": {
      "kind": "alias",
      "name": "DriverCreator",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "typeIndexRef",
              "link": "(core/plugin/index).Driver"
            },
            "params": [
              {
                "kind": "sigParam",
                "name": "pluginName",
                "type": {
                  "kind": "primitive",
                  "type": "string"
                }
              }
            ]
          }
        ],
        "raw": {
          "typeText": "DriverCreator",
          "nodeText": "export type DriverCreator = (pluginName: string) => Driver",
          "nodeFullText": "export type DriverCreator = (pluginName: string) => Driver"
        }
      },
      "raw": {
        "typeText": "DriverCreator",
        "nodeText": "export type DriverCreator = (pluginName: string) => Driver",
        "nodeFullText": "export type DriverCreator = (pluginName: string) => Driver"
      }
    },
    "(core/plugin/index).Driver": {
      "kind": "alias",
      "name": "Driver",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "name",
            "type": {
              "kind": "primitive",
              "type": "string"
            }
          },
          {
            "kind": "prop",
            "name": "extendsWorkflow",
            "type": {
              "kind": "primitive",
              "type": "boolean"
            }
          },
          {
            "kind": "prop",
            "name": "extendsRuntime",
            "type": {
              "kind": "primitive",
              "type": "boolean"
            }
          },
          {
            "kind": "prop",
            "name": "extendsTesting",
            "type": {
              "kind": "primitive",
              "type": "boolean"
            }
          },
          {
            "kind": "prop",
            "name": "loadWorkflowPlugin",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "typeIndexRef",
                    "link": "(core/plugin/index).WorkflowHooks"
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "layout",
                      "type": {
                        "kind": "typeIndexRef",
                        "link": "(framework/layout/layout).Layout"
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(layout: Layout) => WorkflowHooks",
                "nodeText": "(layout: Layout.Layout) => WorkflowHooks",
                "nodeFullText": "(layout: Layout.Layout) => WorkflowHooks"
              }
            }
          },
          {
            "kind": "prop",
            "name": "loadRuntimePlugin",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "union",
                    "isDiscriminated": false,
                    "discriminantProperties": null,
                    "raw": {
                      "typeText": "RuntimeContributions<any> | undefined",
                      "nodeFullText": "",
                      "nodeText": ""
                    },
                    "types": [
                      {
                        "kind": "primitive",
                        "type": "undefined"
                      },
                      {
                        "kind": "alias",
                        "name": "RuntimeContributions",
                        "type": {
                          "kind": "typeIndexRef",
                          "link": "(core/plugin/index).RuntimeContributions"
                        },
                        "raw": {
                          "typeText": "RuntimeContributions<any>",
                          "nodeText": "export type RuntimeContributions<C extends {} = any> = {\n  context?: {\n    typeGen: {\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }\n    create: (req: Express.Request) => C\n  }\n  // todo schema property name\n  nexus?: {\n    typegenAutoConfig?: NexusSchema.core.SchemaConfig['typegenAutoConfig']\n    plugins?: NexusSchema.core.SchemaConfig['plugins']\n  }\n}",
                          "nodeFullText": "/**\n * The possible things that plugins can contribute toward at runtime. Everything\n * is optional.\n */\nexport type RuntimeContributions<C extends {} = any> = {\n  context?: {\n    typeGen: {\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }\n    create: (req: Express.Request) => C\n  }\n  // todo schema property name\n  nexus?: {\n    typegenAutoConfig?: NexusSchema.core.SchemaConfig['typegenAutoConfig']\n    plugins?: NexusSchema.core.SchemaConfig['plugins']\n  }\n}"
                        }
                      }
                    ]
                  },
                  "params": []
                }
              ],
              "raw": {
                "typeText": "() => RuntimeContributions<any> | undefined",
                "nodeText": "() => undefined | RuntimeContributions",
                "nodeFullText": "() => undefined | RuntimeContributions"
              }
            }
          },
          {
            "kind": "prop",
            "name": "loadTestingPlugin",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "union",
                    "isDiscriminated": false,
                    "discriminantProperties": null,
                    "raw": {
                      "typeText": "DeepPartial<TestContextCore> | undefined",
                      "nodeFullText": "",
                      "nodeText": ""
                    },
                    "types": [
                      {
                        "kind": "primitive",
                        "type": "undefined"
                      },
                      {
                        "kind": "alias",
                        "name": "DeepPartial",
                        "type": {
                          "kind": "typeIndexRef",
                          "link": "(lib/utils/index).DeepPartial"
                        },
                        "raw": {
                          "typeText": "DeepPartial<TestContextCore>",
                          "nodeText": "export type DeepPartial<T extends Record<string, any>> = {\n  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]\n} & { [x: string]: any }",
                          "nodeFullText": "export type DeepPartial<T extends Record<string, any>> = {\n  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]\n} & { [x: string]: any }"
                        }
                      }
                    ]
                  },
                  "params": []
                }
              ],
              "raw": {
                "typeText": "() => DeepPartial<TestContextCore> | undefined",
                "nodeText": "() => undefined | TestingContributions",
                "nodeFullText": "() => undefined | TestingContributions"
              }
            }
          }
        ],
        "raw": {
          "typeText": "Driver",
          "nodeText": "export type Driver = {\n  name: string\n  extendsWorkflow: boolean\n  extendsRuntime: boolean\n  extendsTesting: boolean\n  loadWorkflowPlugin: (layout: Layout.Layout) => WorkflowHooks\n  loadRuntimePlugin: () => undefined | RuntimeContributions\n  loadTestingPlugin: () => undefined | TestingContributions\n}",
          "nodeFullText": "export type Driver = {\n  name: string\n  extendsWorkflow: boolean\n  extendsRuntime: boolean\n  extendsTesting: boolean\n  loadWorkflowPlugin: (layout: Layout.Layout) => WorkflowHooks\n  loadRuntimePlugin: () => undefined | RuntimeContributions\n  loadTestingPlugin: () => undefined | TestingContributions\n}"
        }
      },
      "raw": {
        "typeText": "Driver",
        "nodeText": "export type Driver = {\n  name: string\n  extendsWorkflow: boolean\n  extendsRuntime: boolean\n  extendsTesting: boolean\n  loadWorkflowPlugin: (layout: Layout.Layout) => WorkflowHooks\n  loadRuntimePlugin: () => undefined | RuntimeContributions\n  loadTestingPlugin: () => undefined | TestingContributions\n}",
        "nodeFullText": "export type Driver = {\n  name: string\n  extendsWorkflow: boolean\n  extendsRuntime: boolean\n  extendsTesting: boolean\n  loadWorkflowPlugin: (layout: Layout.Layout) => WorkflowHooks\n  loadRuntimePlugin: () => undefined | RuntimeContributions\n  loadTestingPlugin: () => undefined | TestingContributions\n}"
      }
    },
    "(core/plugin/index).WorkflowHooks": {
      "kind": "alias",
      "name": "WorkflowHooks",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "create",
            "type": {
              "kind": "object",
              "props": [
                {
                  "kind": "prop",
                  "name": "onAfterBaseSetup",
                  "type": {
                    "kind": "union",
                    "isDiscriminated": false,
                    "discriminantProperties": null,
                    "raw": {
                      "typeText": "((lens: OnAfterBaseSetupLens) => MaybePromise<void>) | undefined",
                      "nodeFullText": "",
                      "nodeText": ""
                    },
                    "types": [
                      {
                        "kind": "primitive",
                        "type": "undefined"
                      },
                      {
                        "kind": "callable",
                        "isOverloaded": false,
                        "hasProps": false,
                        "props": [],
                        "sigs": [
                          {
                            "kind": "sig",
                            "return": {
                              "kind": "typeIndexRef",
                              "link": "(lib/utils/index).MaybePromise"
                            },
                            "params": [
                              {
                                "kind": "sigParam",
                                "name": "lens",
                                "type": {
                                  "kind": "typeIndexRef",
                                  "link": "(core/plugin/index).OnAfterBaseSetupLens"
                                }
                              }
                            ]
                          }
                        ],
                        "raw": {
                          "typeText": "(lens: OnAfterBaseSetupLens) => MaybePromise<void>",
                          "nodeText": "(lens: OnAfterBaseSetupLens) => MaybePromise",
                          "nodeFullText": "(lens: OnAfterBaseSetupLens) => MaybePromise"
                        }
                      }
                    ]
                  }
                }
              ],
              "raw": {
                "typeText": "{ onAfterBaseSetup?: ((lens: OnAfterBaseSetupLens) => MaybePromise<void>) | undefined; }",
                "nodeText": "{\n    onAfterBaseSetup?: (lens: OnAfterBaseSetupLens) => MaybePromise\n  }",
                "nodeFullText": "{\n    onAfterBaseSetup?: (lens: OnAfterBaseSetupLens) => MaybePromise\n  }"
              }
            }
          },
          {
            "kind": "prop",
            "name": "dev",
            "type": {
              "kind": "object",
              "props": [
                {
                  "kind": "prop",
                  "name": "onStart",
                  "type": {
                    "kind": "union",
                    "isDiscriminated": false,
                    "discriminantProperties": null,
                    "raw": {
                      "typeText": "SideEffector | undefined",
                      "nodeFullText": "",
                      "nodeText": ""
                    },
                    "types": [
                      {
                        "kind": "primitive",
                        "type": "undefined"
                      },
                      {
                        "kind": "alias",
                        "name": "SideEffector",
                        "type": {
                          "kind": "typeIndexRef",
                          "link": "(lib/utils/index).SideEffector"
                        },
                        "raw": {
                          "typeText": "SideEffector",
                          "nodeText": "export type SideEffector = () => MaybePromise",
                          "nodeFullText": "export type SideEffector = () => MaybePromise"
                        }
                      }
                    ]
                  }
                },
                {
                  "kind": "prop",
                  "name": "onFileWatcherEvent",
                  "type": {
                    "kind": "union",
                    "isDiscriminated": false,
                    "discriminantProperties": null,
                    "raw": {
                      "typeText": "FileWatcherEventCallback | undefined",
                      "nodeFullText": "",
                      "nodeText": ""
                    },
                    "types": [
                      {
                        "kind": "primitive",
                        "type": "undefined"
                      },
                      {
                        "kind": "alias",
                        "name": "FileWatcherEventCallback",
                        "type": {
                          "kind": "typeIndexRef",
                          "link": "(watcher/chokidar).FileWatcherEventCallback"
                        },
                        "raw": {
                          "typeText": "FileWatcherEventCallback",
                          "nodeText": "export type FileWatcherEventCallback = (\n  eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir',\n  path: string,\n  stats: fs.Stats | undefined,\n  runner: {\n    restart: (file: string) => void /* stop: () => void, start: () => void */\n  } //TODO: add stop and start methods\n) => void",
                          "nodeFullText": "export type FileWatcherEventCallback = (\n  eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir',\n  path: string,\n  stats: fs.Stats | undefined,\n  runner: {\n    restart: (file: string) => void /* stop: () => void, start: () => void */\n  } //TODO: add stop and start methods\n) => void"
                        }
                      }
                    ]
                  }
                },
                {
                  "kind": "prop",
                  "name": "addToWatcherSettings",
                  "type": {
                    "kind": "object",
                    "props": [
                      {
                        "kind": "prop",
                        "name": "watchFilePatterns",
                        "type": {
                          "kind": "union",
                          "isDiscriminated": false,
                          "discriminantProperties": null,
                          "raw": {
                            "typeText": "string[] | undefined",
                            "nodeFullText": "",
                            "nodeText": ""
                          },
                          "types": [
                            {
                              "kind": "primitive",
                              "type": "undefined"
                            },
                            {
                              "kind": "array",
                              "innerType": {
                                "kind": "primitive",
                                "type": "string"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "kind": "prop",
                        "name": "listeners",
                        "type": {
                          "kind": "union",
                          "isDiscriminated": false,
                          "discriminantProperties": null,
                          "raw": {
                            "typeText": "{ app?: { ignoreFilePatterns?: string[] | undefined; } | undefined; plugin?: { allowFilePatterns?: string[] | undefined; ignoreFilePatterns?: string[] | undefined; } | undefined; } | undefined",
                            "nodeFullText": "",
                            "nodeText": ""
                          },
                          "types": [
                            {
                              "kind": "primitive",
                              "type": "undefined"
                            },
                            {
                              "kind": "object",
                              "props": [
                                {
                                  "kind": "prop",
                                  "name": "app",
                                  "type": {
                                    "kind": "union",
                                    "isDiscriminated": false,
                                    "discriminantProperties": null,
                                    "raw": {
                                      "typeText": "{ ignoreFilePatterns?: string[] | undefined; } | undefined",
                                      "nodeFullText": "",
                                      "nodeText": ""
                                    },
                                    "types": [
                                      {
                                        "kind": "primitive",
                                        "type": "undefined"
                                      },
                                      {
                                        "kind": "object",
                                        "props": [
                                          {
                                            "kind": "prop",
                                            "name": "ignoreFilePatterns",
                                            "type": {
                                              "kind": "union",
                                              "isDiscriminated": false,
                                              "discriminantProperties": null,
                                              "raw": {
                                                "typeText": "string[] | undefined",
                                                "nodeFullText": "",
                                                "nodeText": ""
                                              },
                                              "types": [
                                                {
                                                  "kind": "primitive",
                                                  "type": "undefined"
                                                },
                                                {
                                                  "kind": "array",
                                                  "innerType": {
                                                    "kind": "primitive",
                                                    "type": "string"
                                                  }
                                                }
                                              ]
                                            }
                                          }
                                        ],
                                        "raw": {
                                          "typeText": "{ ignoreFilePatterns?: string[] | undefined; }",
                                          "nodeText": "{\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }",
                                          "nodeFullText": "{\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "kind": "prop",
                                  "name": "plugin",
                                  "type": {
                                    "kind": "union",
                                    "isDiscriminated": false,
                                    "discriminantProperties": null,
                                    "raw": {
                                      "typeText": "{ allowFilePatterns?: string[] | undefined; ignoreFilePatterns?: string[] | undefined; } | undefined",
                                      "nodeFullText": "",
                                      "nodeText": ""
                                    },
                                    "types": [
                                      {
                                        "kind": "primitive",
                                        "type": "undefined"
                                      },
                                      {
                                        "kind": "object",
                                        "props": [
                                          {
                                            "kind": "prop",
                                            "name": "allowFilePatterns",
                                            "type": {
                                              "kind": "union",
                                              "isDiscriminated": false,
                                              "discriminantProperties": null,
                                              "raw": {
                                                "typeText": "string[] | undefined",
                                                "nodeFullText": "",
                                                "nodeText": ""
                                              },
                                              "types": [
                                                {
                                                  "kind": "primitive",
                                                  "type": "undefined"
                                                },
                                                {
                                                  "kind": "array",
                                                  "innerType": {
                                                    "kind": "primitive",
                                                    "type": "string"
                                                  }
                                                }
                                              ]
                                            }
                                          },
                                          {
                                            "kind": "prop",
                                            "name": "ignoreFilePatterns",
                                            "type": {
                                              "kind": "union",
                                              "isDiscriminated": false,
                                              "discriminantProperties": null,
                                              "raw": {
                                                "typeText": "string[] | undefined",
                                                "nodeFullText": "",
                                                "nodeText": ""
                                              },
                                              "types": [
                                                {
                                                  "kind": "primitive",
                                                  "type": "undefined"
                                                },
                                                {
                                                  "kind": "array",
                                                  "innerType": {
                                                    "kind": "primitive",
                                                    "type": "string"
                                                  }
                                                }
                                              ]
                                            }
                                          }
                                        ],
                                        "raw": {
                                          "typeText": "{ allowFilePatterns?: string[] | undefined; ignoreFilePatterns?: string[] | undefined; }",
                                          "nodeText": "{\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }",
                                          "nodeFullText": "{\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ],
                              "raw": {
                                "typeText": "{ app?: { ignoreFilePatterns?: string[] | undefined; } | undefined; plugin?: { allowFilePatterns?: string[] | undefined; ignoreFilePatterns?: string[] | undefined; } | undefined; }",
                                "nodeText": "{\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }",
                                "nodeFullText": "{\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }"
                              }
                            }
                          ]
                        }
                      }
                    ],
                    "raw": {
                      "typeText": "{ watchFilePatterns?: string[] | undefined; listeners?: { app?: { ignoreFilePatterns?: string[] | undefined; } | undefined; plugin?: { allowFilePatterns?: string[] | undefined; ignoreFilePatterns?: string[] | undefined; } | undefined; } | undefined; }",
                      "nodeText": "{\n      /**\n       * Set additional files to be watched for the app and plugin listeners\n       */\n      watchFilePatterns?: string[]\n      listeners?: {\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }\n    }",
                      "nodeFullText": "{\n      /**\n       * Set additional files to be watched for the app and plugin listeners\n       */\n      watchFilePatterns?: string[]\n      listeners?: {\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }\n    }"
                    }
                  }
                }
              ],
              "raw": {
                "typeText": "{ onStart?: SideEffector | undefined; onFileWatcherEvent?: FileWatcherEventCallback | undefined; addToWatcherSettings: { watchFilePatterns?: string[] | undefined; listeners?: { ...; } | undefined; }; }",
                "nodeText": "{\n    onStart?: SideEffector\n    onFileWatcherEvent?: Chokidar.FileWatcherEventCallback\n    addToWatcherSettings: {\n      /**\n       * Set additional files to be watched for the app and plugin listeners\n       */\n      watchFilePatterns?: string[]\n      listeners?: {\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }\n    }\n  }",
                "nodeFullText": "{\n    onStart?: SideEffector\n    onFileWatcherEvent?: Chokidar.FileWatcherEventCallback\n    addToWatcherSettings: {\n      /**\n       * Set additional files to be watched for the app and plugin listeners\n       */\n      watchFilePatterns?: string[]\n      listeners?: {\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }\n    }\n  }"
              }
            }
          },
          {
            "kind": "prop",
            "name": "generate",
            "type": {
              "kind": "object",
              "props": [
                {
                  "kind": "prop",
                  "name": "onStart",
                  "type": {
                    "kind": "union",
                    "isDiscriminated": false,
                    "discriminantProperties": null,
                    "raw": {
                      "typeText": "SideEffector | undefined",
                      "nodeFullText": "",
                      "nodeText": ""
                    },
                    "types": [
                      {
                        "kind": "primitive",
                        "type": "undefined"
                      },
                      {
                        "kind": "alias",
                        "name": "SideEffector",
                        "type": {
                          "kind": "typeIndexRef",
                          "link": "(lib/utils/index).SideEffector"
                        },
                        "raw": {
                          "typeText": "SideEffector",
                          "nodeText": "export type SideEffector = () => MaybePromise",
                          "nodeFullText": "export type SideEffector = () => MaybePromise"
                        }
                      }
                    ]
                  }
                }
              ],
              "raw": {
                "typeText": "{ onStart?: SideEffector | undefined; }",
                "nodeText": "{\n    onStart?: SideEffector\n  }",
                "nodeFullText": "{\n    onStart?: SideEffector\n  }"
              }
            }
          },
          {
            "kind": "prop",
            "name": "build",
            "type": {
              "kind": "object",
              "props": [
                {
                  "kind": "prop",
                  "name": "onStart",
                  "type": {
                    "kind": "union",
                    "isDiscriminated": false,
                    "discriminantProperties": null,
                    "raw": {
                      "typeText": "SideEffector | undefined",
                      "nodeFullText": "",
                      "nodeText": ""
                    },
                    "types": [
                      {
                        "kind": "primitive",
                        "type": "undefined"
                      },
                      {
                        "kind": "alias",
                        "name": "SideEffector",
                        "type": {
                          "kind": "typeIndexRef",
                          "link": "(lib/utils/index).SideEffector"
                        },
                        "raw": {
                          "typeText": "SideEffector",
                          "nodeText": "export type SideEffector = () => MaybePromise",
                          "nodeFullText": "export type SideEffector = () => MaybePromise"
                        }
                      }
                    ]
                  }
                }
              ],
              "raw": {
                "typeText": "{ onStart?: SideEffector | undefined; }",
                "nodeText": "{\n    onStart?: SideEffector\n  }",
                "nodeFullText": "{\n    onStart?: SideEffector\n  }"
              }
            }
          },
          {
            "kind": "prop",
            "name": "db",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "{ init: { onStart: SideEffector; }; migrate: { plan: { onStart: (ctx: DbMigratePlanContext) => void; }; apply: { onStart: (ctx: DbMigrateApplyContext) => void; }; rollback: { ...; }; }; ui: { ...; }; } | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "object",
                  "props": [
                    {
                      "kind": "prop",
                      "name": "init",
                      "type": {
                        "kind": "object",
                        "props": [
                          {
                            "kind": "prop",
                            "name": "onStart",
                            "type": {
                              "kind": "typeIndexRef",
                              "link": "(lib/utils/index).SideEffector"
                            }
                          }
                        ],
                        "raw": {
                          "typeText": "{ onStart: SideEffector; }",
                          "nodeText": "{\n      onStart: SideEffector\n    }",
                          "nodeFullText": "{\n      onStart: SideEffector\n    }"
                        }
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "migrate",
                      "type": {
                        "kind": "object",
                        "props": [
                          {
                            "kind": "prop",
                            "name": "plan",
                            "type": {
                              "kind": "object",
                              "props": [
                                {
                                  "kind": "prop",
                                  "name": "onStart",
                                  "type": {
                                    "kind": "callable",
                                    "isOverloaded": false,
                                    "hasProps": false,
                                    "props": [],
                                    "sigs": [
                                      {
                                        "kind": "sig",
                                        "return": {
                                          "kind": "primitive",
                                          "type": "void"
                                        },
                                        "params": [
                                          {
                                            "kind": "sigParam",
                                            "name": "ctx",
                                            "type": {
                                              "kind": "typeIndexRef",
                                              "link": "(core/plugin/index).DbMigratePlanContext"
                                            }
                                          }
                                        ]
                                      }
                                    ],
                                    "raw": {
                                      "typeText": "(ctx: DbMigratePlanContext) => void",
                                      "nodeText": "(ctx: DbMigratePlanContext) => void",
                                      "nodeFullText": "(ctx: DbMigratePlanContext) => void"
                                    }
                                  }
                                }
                              ],
                              "raw": {
                                "typeText": "{ onStart: (ctx: DbMigratePlanContext) => void; }",
                                "nodeText": "{\n        onStart: (ctx: DbMigratePlanContext) => void\n      }",
                                "nodeFullText": "{\n        onStart: (ctx: DbMigratePlanContext) => void\n      }"
                              }
                            }
                          },
                          {
                            "kind": "prop",
                            "name": "apply",
                            "type": {
                              "kind": "object",
                              "props": [
                                {
                                  "kind": "prop",
                                  "name": "onStart",
                                  "type": {
                                    "kind": "callable",
                                    "isOverloaded": false,
                                    "hasProps": false,
                                    "props": [],
                                    "sigs": [
                                      {
                                        "kind": "sig",
                                        "return": {
                                          "kind": "primitive",
                                          "type": "void"
                                        },
                                        "params": [
                                          {
                                            "kind": "sigParam",
                                            "name": "ctx",
                                            "type": {
                                              "kind": "typeIndexRef",
                                              "link": "(core/plugin/index).DbMigrateApplyContext"
                                            }
                                          }
                                        ]
                                      }
                                    ],
                                    "raw": {
                                      "typeText": "(ctx: DbMigrateApplyContext) => void",
                                      "nodeText": "(ctx: DbMigrateApplyContext) => void",
                                      "nodeFullText": "(ctx: DbMigrateApplyContext) => void"
                                    }
                                  }
                                }
                              ],
                              "raw": {
                                "typeText": "{ onStart: (ctx: DbMigrateApplyContext) => void; }",
                                "nodeText": "{\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }",
                                "nodeFullText": "{\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }"
                              }
                            }
                          },
                          {
                            "kind": "prop",
                            "name": "rollback",
                            "type": {
                              "kind": "object",
                              "props": [
                                {
                                  "kind": "prop",
                                  "name": "onStart",
                                  "type": {
                                    "kind": "typeIndexRef",
                                    "link": "(lib/utils/index).SideEffector"
                                  }
                                }
                              ],
                              "raw": {
                                "typeText": "{ onStart: SideEffector; }",
                                "nodeText": "{\n        onStart: SideEffector\n      }",
                                "nodeFullText": "{\n        onStart: SideEffector\n      }"
                              }
                            }
                          }
                        ],
                        "raw": {
                          "typeText": "{ plan: { onStart: (ctx: DbMigratePlanContext) => void; }; apply: { onStart: (ctx: DbMigrateApplyContext) => void; }; rollback: { onStart: SideEffector; }; }",
                          "nodeText": "{\n      plan: {\n        onStart: (ctx: DbMigratePlanContext) => void\n      }\n      apply: {\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }\n      rollback: {\n        onStart: SideEffector\n      }\n    }",
                          "nodeFullText": "{\n      plan: {\n        onStart: (ctx: DbMigratePlanContext) => void\n      }\n      apply: {\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }\n      rollback: {\n        onStart: SideEffector\n      }\n    }"
                        }
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "ui",
                      "type": {
                        "kind": "object",
                        "props": [
                          {
                            "kind": "prop",
                            "name": "onStart",
                            "type": {
                              "kind": "callable",
                              "isOverloaded": false,
                              "hasProps": false,
                              "props": [],
                              "sigs": [
                                {
                                  "kind": "sig",
                                  "return": {
                                    "kind": "primitive",
                                    "type": "void"
                                  },
                                  "params": [
                                    {
                                      "kind": "sigParam",
                                      "name": "ctx",
                                      "type": {
                                        "kind": "typeIndexRef",
                                        "link": "(core/plugin/index).DbUiContext"
                                      }
                                    }
                                  ]
                                }
                              ],
                              "raw": {
                                "typeText": "(ctx: DbUiContext) => void",
                                "nodeText": "(ctx: DbUiContext) => void",
                                "nodeFullText": "(ctx: DbUiContext) => void"
                              }
                            }
                          }
                        ],
                        "raw": {
                          "typeText": "{ onStart: (ctx: DbUiContext) => void; }",
                          "nodeText": "{\n      onStart: (ctx: DbUiContext) => void\n    }",
                          "nodeFullText": "{\n      onStart: (ctx: DbUiContext) => void\n    }"
                        }
                      }
                    }
                  ],
                  "raw": {
                    "typeText": "{ init: { onStart: SideEffector; }; migrate: { plan: { onStart: (ctx: DbMigratePlanContext) => void; }; apply: { onStart: (ctx: DbMigrateApplyContext) => void; }; rollback: { ...; }; }; ui: { ...; }; }",
                    "nodeText": "{\n    init: {\n      onStart: SideEffector\n    }\n    migrate: {\n      plan: {\n        onStart: (ctx: DbMigratePlanContext) => void\n      }\n      apply: {\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }\n      rollback: {\n        onStart: SideEffector\n      }\n    }\n    ui: {\n      onStart: (ctx: DbUiContext) => void\n    }\n  }",
                    "nodeFullText": "{\n    init: {\n      onStart: SideEffector\n    }\n    migrate: {\n      plan: {\n        onStart: (ctx: DbMigratePlanContext) => void\n      }\n      apply: {\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }\n      rollback: {\n        onStart: SideEffector\n      }\n    }\n    ui: {\n      onStart: (ctx: DbUiContext) => void\n    }\n  }"
                  }
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "WorkflowHooks",
          "nodeText": "export type WorkflowHooks = {\n  create: {\n    onAfterBaseSetup?: (lens: OnAfterBaseSetupLens) => MaybePromise\n  }\n  dev: {\n    onStart?: SideEffector\n    onFileWatcherEvent?: Chokidar.FileWatcherEventCallback\n    addToWatcherSettings: {\n      /**\n       * Set additional files to be watched for the app and plugin listeners\n       */\n      watchFilePatterns?: string[]\n      listeners?: {\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }\n    }\n  }\n  generate: {\n    onStart?: SideEffector\n  }\n  build: {\n    onStart?: SideEffector\n  }\n  db?: {\n    init: {\n      onStart: SideEffector\n    }\n    migrate: {\n      plan: {\n        onStart: (ctx: DbMigratePlanContext) => void\n      }\n      apply: {\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }\n      rollback: {\n        onStart: SideEffector\n      }\n    }\n    ui: {\n      onStart: (ctx: DbUiContext) => void\n    }\n  }\n}",
          "nodeFullText": "export type WorkflowHooks = {\n  create: {\n    onAfterBaseSetup?: (lens: OnAfterBaseSetupLens) => MaybePromise\n  }\n  dev: {\n    onStart?: SideEffector\n    onFileWatcherEvent?: Chokidar.FileWatcherEventCallback\n    addToWatcherSettings: {\n      /**\n       * Set additional files to be watched for the app and plugin listeners\n       */\n      watchFilePatterns?: string[]\n      listeners?: {\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }\n    }\n  }\n  generate: {\n    onStart?: SideEffector\n  }\n  build: {\n    onStart?: SideEffector\n  }\n  db?: {\n    init: {\n      onStart: SideEffector\n    }\n    migrate: {\n      plan: {\n        onStart: (ctx: DbMigratePlanContext) => void\n      }\n      apply: {\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }\n      rollback: {\n        onStart: SideEffector\n      }\n    }\n    ui: {\n      onStart: (ctx: DbUiContext) => void\n    }\n  }\n}"
        }
      },
      "raw": {
        "typeText": "WorkflowHooks",
        "nodeText": "export type WorkflowHooks = {\n  create: {\n    onAfterBaseSetup?: (lens: OnAfterBaseSetupLens) => MaybePromise\n  }\n  dev: {\n    onStart?: SideEffector\n    onFileWatcherEvent?: Chokidar.FileWatcherEventCallback\n    addToWatcherSettings: {\n      /**\n       * Set additional files to be watched for the app and plugin listeners\n       */\n      watchFilePatterns?: string[]\n      listeners?: {\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }\n    }\n  }\n  generate: {\n    onStart?: SideEffector\n  }\n  build: {\n    onStart?: SideEffector\n  }\n  db?: {\n    init: {\n      onStart: SideEffector\n    }\n    migrate: {\n      plan: {\n        onStart: (ctx: DbMigratePlanContext) => void\n      }\n      apply: {\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }\n      rollback: {\n        onStart: SideEffector\n      }\n    }\n    ui: {\n      onStart: (ctx: DbUiContext) => void\n    }\n  }\n}",
        "nodeFullText": "export type WorkflowHooks = {\n  create: {\n    onAfterBaseSetup?: (lens: OnAfterBaseSetupLens) => MaybePromise\n  }\n  dev: {\n    onStart?: SideEffector\n    onFileWatcherEvent?: Chokidar.FileWatcherEventCallback\n    addToWatcherSettings: {\n      /**\n       * Set additional files to be watched for the app and plugin listeners\n       */\n      watchFilePatterns?: string[]\n      listeners?: {\n        /**\n         * Define the watcher settings for the app listener\n         */\n        app?: {\n          /**\n           * Set files patterns that should not trigger a server restart by the app\n           */\n          ignoreFilePatterns?: string[]\n        }\n        /**\n         * Define the watcher settings for your plugin listener\n         */\n        plugin?: {\n          /**\n           * Set file patterns that should trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns\n           * When set with `plugin.ignoreFilePatterns`, `dev.onFileWatcherEvent` will only react to changes made to the files which matches the `plugin.allowFilePatterns` patterns, minus the files which matches `plugin.ignoreFilePatterns`\n           */\n          allowFilePatterns?: string[]\n          /**\n           * Set file patterns that should not trigger `dev.onFileWatcherEvent`\n           * When set without `plugin.allowFilePatterns`, `dev.onFileWatcherEvent` will react to changes made to all files watched except the files which matches the `plugin.ignoreFilePatterns` patterns\n           * When set with `plugin.allowFilePatterns`, , `dev.onFileWatcherEvent` will react to changes made to all files matched by `plugin.allowFilesPatterns` except the files which matches the `plugin.ignoreFilePatterns` patterns\n           */\n          ignoreFilePatterns?: string[]\n        }\n      }\n    }\n  }\n  generate: {\n    onStart?: SideEffector\n  }\n  build: {\n    onStart?: SideEffector\n  }\n  db?: {\n    init: {\n      onStart: SideEffector\n    }\n    migrate: {\n      plan: {\n        onStart: (ctx: DbMigratePlanContext) => void\n      }\n      apply: {\n        onStart: (ctx: DbMigrateApplyContext) => void\n      }\n      rollback: {\n        onStart: SideEffector\n      }\n    }\n    ui: {\n      onStart: (ctx: DbUiContext) => void\n    }\n  }\n}"
      }
    },
    "(core/plugin/index).OnAfterBaseSetupLens": {
      "kind": "alias",
      "name": "OnAfterBaseSetupLens",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "database",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "\"SQLite\" | \"MySQL\" | \"PostgreSQL\" | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "literal",
                  "name": "\"SQLite\"",
                  "base": "string"
                },
                {
                  "kind": "literal",
                  "name": "\"MySQL\"",
                  "base": "string"
                },
                {
                  "kind": "literal",
                  "name": "\"PostgreSQL\"",
                  "base": "string"
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "connectionURI",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "string | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "primitive",
                  "type": "string"
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "OnAfterBaseSetupLens",
          "nodeText": "export type OnAfterBaseSetupLens = {\n  database: 'SQLite' | 'MySQL' | 'PostgreSQL' | undefined\n  connectionURI: string | undefined\n}",
          "nodeFullText": "export type OnAfterBaseSetupLens = {\n  database: 'SQLite' | 'MySQL' | 'PostgreSQL' | undefined\n  connectionURI: string | undefined\n}"
        }
      },
      "raw": {
        "typeText": "OnAfterBaseSetupLens",
        "nodeText": "export type OnAfterBaseSetupLens = {\n  database: 'SQLite' | 'MySQL' | 'PostgreSQL' | undefined\n  connectionURI: string | undefined\n}",
        "nodeFullText": "export type OnAfterBaseSetupLens = {\n  database: 'SQLite' | 'MySQL' | 'PostgreSQL' | undefined\n  connectionURI: string | undefined\n}"
      }
    },
    "(lib/utils/index).SideEffector": {
      "kind": "alias",
      "name": "SideEffector",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "typeIndexRef",
              "link": "(lib/utils/index).MaybePromise"
            },
            "params": []
          }
        ],
        "raw": {
          "typeText": "SideEffector",
          "nodeText": "export type SideEffector = () => MaybePromise",
          "nodeFullText": "export type SideEffector = () => MaybePromise"
        }
      },
      "raw": {
        "typeText": "SideEffector",
        "nodeText": "export type SideEffector = () => MaybePromise",
        "nodeFullText": "export type SideEffector = () => MaybePromise"
      }
    },
    "(watcher/chokidar).FileWatcherEventCallback": {
      "kind": "alias",
      "name": "FileWatcherEventCallback",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "primitive",
              "type": "void"
            },
            "params": [
              {
                "kind": "sigParam",
                "name": "eventName",
                "type": {
                  "kind": "union",
                  "isDiscriminated": false,
                  "discriminantProperties": null,
                  "raw": {
                    "typeText": "\"add\" | \"addDir\" | \"change\" | \"unlink\" | \"unlinkDir\"",
                    "nodeFullText": "",
                    "nodeText": ""
                  },
                  "types": [
                    {
                      "kind": "literal",
                      "name": "\"add\"",
                      "base": "string"
                    },
                    {
                      "kind": "literal",
                      "name": "\"addDir\"",
                      "base": "string"
                    },
                    {
                      "kind": "literal",
                      "name": "\"change\"",
                      "base": "string"
                    },
                    {
                      "kind": "literal",
                      "name": "\"unlink\"",
                      "base": "string"
                    },
                    {
                      "kind": "literal",
                      "name": "\"unlinkDir\"",
                      "base": "string"
                    }
                  ]
                }
              },
              {
                "kind": "sigParam",
                "name": "path",
                "type": {
                  "kind": "primitive",
                  "type": "string"
                }
              },
              {
                "kind": "sigParam",
                "name": "stats",
                "type": {
                  "kind": "union",
                  "isDiscriminated": false,
                  "discriminantProperties": null,
                  "raw": {
                    "typeText": "Stats | undefined",
                    "nodeFullText": "",
                    "nodeText": ""
                  },
                  "types": [
                    {
                      "kind": "primitive",
                      "type": "undefined"
                    },
                    {
                      "kind": "unsupported",
                      "raw": {
                        "typeText": "Stats",
                        "nodeText": "interface Stats extends StatsBase<number> {\n    }",
                        "nodeFullText": "interface Stats extends StatsBase<number> {\n    }"
                      }
                    }
                  ]
                }
              },
              {
                "kind": "sigParam",
                "name": "runner",
                "type": {
                  "kind": "object",
                  "props": [
                    {
                      "kind": "prop",
                      "name": "restart",
                      "type": {
                        "kind": "callable",
                        "isOverloaded": false,
                        "hasProps": false,
                        "props": [],
                        "sigs": [
                          {
                            "kind": "sig",
                            "return": {
                              "kind": "primitive",
                              "type": "void"
                            },
                            "params": [
                              {
                                "kind": "sigParam",
                                "name": "file",
                                "type": {
                                  "kind": "primitive",
                                  "type": "string"
                                }
                              }
                            ]
                          }
                        ],
                        "raw": {
                          "typeText": "(file: string) => void",
                          "nodeText": "(file: string) => void",
                          "nodeFullText": "(file: string) => void"
                        }
                      }
                    }
                  ],
                  "raw": {
                    "typeText": "{ restart: (file: string) => void; }",
                    "nodeText": "{\n    restart: (file: string) => void /* stop: () => void, start: () => void */\n  }",
                    "nodeFullText": "{\n    restart: (file: string) => void /* stop: () => void, start: () => void */\n  }"
                  }
                }
              }
            ]
          }
        ],
        "raw": {
          "typeText": "FileWatcherEventCallback",
          "nodeText": "export type FileWatcherEventCallback = (\n  eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir',\n  path: string,\n  stats: fs.Stats | undefined,\n  runner: {\n    restart: (file: string) => void /* stop: () => void, start: () => void */\n  } //TODO: add stop and start methods\n) => void",
          "nodeFullText": "export type FileWatcherEventCallback = (\n  eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir',\n  path: string,\n  stats: fs.Stats | undefined,\n  runner: {\n    restart: (file: string) => void /* stop: () => void, start: () => void */\n  } //TODO: add stop and start methods\n) => void"
        }
      },
      "raw": {
        "typeText": "FileWatcherEventCallback",
        "nodeText": "export type FileWatcherEventCallback = (\n  eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir',\n  path: string,\n  stats: fs.Stats | undefined,\n  runner: {\n    restart: (file: string) => void /* stop: () => void, start: () => void */\n  } //TODO: add stop and start methods\n) => void",
        "nodeFullText": "export type FileWatcherEventCallback = (\n  eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir',\n  path: string,\n  stats: fs.Stats | undefined,\n  runner: {\n    restart: (file: string) => void /* stop: () => void, start: () => void */\n  } //TODO: add stop and start methods\n) => void"
      }
    },
    "(core/plugin/index).DbMigratePlanContext": {
      "kind": "alias",
      "name": "DbMigratePlanContext",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "migrationName",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "string | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "primitive",
                  "type": "string"
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "DbMigratePlanContext",
          "nodeText": "export type DbMigratePlanContext = {\n  migrationName: string | undefined\n}",
          "nodeFullText": "export type DbMigratePlanContext = {\n  migrationName: string | undefined\n}"
        }
      },
      "raw": {
        "typeText": "DbMigratePlanContext",
        "nodeText": "export type DbMigratePlanContext = {\n  migrationName: string | undefined\n}",
        "nodeFullText": "export type DbMigratePlanContext = {\n  migrationName: string | undefined\n}"
      }
    },
    "(core/plugin/index).DbMigrateApplyContext": {
      "kind": "alias",
      "name": "DbMigrateApplyContext",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "force",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "boolean | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "literal",
                  "name": "false",
                  "base": "boolean"
                },
                {
                  "kind": "literal",
                  "name": "true",
                  "base": "boolean"
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "DbMigrateApplyContext",
          "nodeText": "export type DbMigrateApplyContext = {\n  force: boolean | undefined\n}",
          "nodeFullText": "export type DbMigrateApplyContext = {\n  force: boolean | undefined\n}"
        }
      },
      "raw": {
        "typeText": "DbMigrateApplyContext",
        "nodeText": "export type DbMigrateApplyContext = {\n  force: boolean | undefined\n}",
        "nodeFullText": "export type DbMigrateApplyContext = {\n  force: boolean | undefined\n}"
      }
    },
    "(core/plugin/index).DbUiContext": {
      "kind": "alias",
      "name": "DbUiContext",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "port",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "number | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "primitive",
                  "type": "number"
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "DbUiContext",
          "nodeText": "export type DbUiContext = {\n  port?: number\n}",
          "nodeFullText": "export type DbUiContext = {\n  port?: number\n}"
        }
      },
      "raw": {
        "typeText": "DbUiContext",
        "nodeText": "export type DbUiContext = {\n  port?: number\n}",
        "nodeFullText": "export type DbUiContext = {\n  port?: number\n}"
      }
    },
    "(framework/layout/layout).Layout": {
      "kind": "alias",
      "name": "Layout",
      "type": {
        "kind": "intersection",
        "raw": {
          "typeText": "Layout",
          "nodeText": "export type Layout = Data & {\n  /**\n   * Property that aliases all the and only the data properties, makes it\n   * easy to e.g. serialize just the data.\n   */\n  data: Data\n  projectRelative(filePath: string): string\n  sourceRelative(filePath: string): string\n  sourcePath(subPath: string): string\n  packageManager: PackageManager.PackageManager\n}",
          "nodeFullText": "/**\n * Layout represents the important edges of the project to support things like\n * scaffolding, build, and dev against the correct paths.\n */\nexport type Layout = Data & {\n  /**\n   * Property that aliases all the and only the data properties, makes it\n   * easy to e.g. serialize just the data.\n   */\n  data: Data\n  projectRelative(filePath: string): string\n  sourceRelative(filePath: string): string\n  sourcePath(subPath: string): string\n  packageManager: PackageManager.PackageManager\n}"
        },
        "types": [
          {
            "kind": "typeIndexRef",
            "link": "(framework/layout/layout).ScanResult"
          },
          {
            "kind": "object",
            "props": [
              {
                "kind": "prop",
                "name": "buildOutput",
                "type": {
                  "kind": "primitive",
                  "type": "string"
                }
              }
            ],
            "raw": {
              "typeText": "{ buildOutput: string; }",
              "nodeText": "{\n  buildOutput: string\n}",
              "nodeFullText": "{\n  buildOutput: string\n}"
            }
          },
          {
            "kind": "object",
            "props": [
              {
                "kind": "prop",
                "name": "data",
                "type": {
                  "kind": "typeIndexRef",
                  "link": "(framework/layout/layout).Data"
                }
              },
              {
                "kind": "prop",
                "name": "projectRelative",
                "type": {
                  "kind": "callable",
                  "isOverloaded": false,
                  "hasProps": false,
                  "props": [],
                  "sigs": [
                    {
                      "kind": "sig",
                      "return": {
                        "kind": "primitive",
                        "type": "string"
                      },
                      "params": [
                        {
                          "kind": "sigParam",
                          "name": "filePath",
                          "type": {
                            "kind": "primitive",
                            "type": "string"
                          }
                        }
                      ]
                    }
                  ],
                  "raw": {
                    "typeText": "(filePath: string) => string",
                    "nodeText": "projectRelative(filePath: string): string",
                    "nodeFullText": "projectRelative(filePath: string): string"
                  }
                }
              },
              {
                "kind": "prop",
                "name": "sourceRelative",
                "type": {
                  "kind": "callable",
                  "isOverloaded": false,
                  "hasProps": false,
                  "props": [],
                  "sigs": [
                    {
                      "kind": "sig",
                      "return": {
                        "kind": "primitive",
                        "type": "string"
                      },
                      "params": [
                        {
                          "kind": "sigParam",
                          "name": "filePath",
                          "type": {
                            "kind": "primitive",
                            "type": "string"
                          }
                        }
                      ]
                    }
                  ],
                  "raw": {
                    "typeText": "(filePath: string) => string",
                    "nodeText": "sourceRelative(filePath: string): string",
                    "nodeFullText": "sourceRelative(filePath: string): string"
                  }
                }
              },
              {
                "kind": "prop",
                "name": "sourcePath",
                "type": {
                  "kind": "callable",
                  "isOverloaded": false,
                  "hasProps": false,
                  "props": [],
                  "sigs": [
                    {
                      "kind": "sig",
                      "return": {
                        "kind": "primitive",
                        "type": "string"
                      },
                      "params": [
                        {
                          "kind": "sigParam",
                          "name": "subPath",
                          "type": {
                            "kind": "primitive",
                            "type": "string"
                          }
                        }
                      ]
                    }
                  ],
                  "raw": {
                    "typeText": "(subPath: string) => string",
                    "nodeText": "sourcePath(subPath: string): string",
                    "nodeFullText": "sourcePath(subPath: string): string"
                  }
                }
              },
              {
                "kind": "prop",
                "name": "packageManager",
                "type": {
                  "kind": "typeIndexRef",
                  "link": "(utils/package-manager).PackageManager"
                }
              }
            ],
            "raw": {
              "typeText": "{ data: Data; projectRelative(filePath: string): string; sourceRelative(filePath: string): string; sourcePath(subPath: string): string; packageManager: PackageManager; }",
              "nodeText": "{\n  /**\n   * Property that aliases all the and only the data properties, makes it\n   * easy to e.g. serialize just the data.\n   */\n  data: Data\n  projectRelative(filePath: string): string\n  sourceRelative(filePath: string): string\n  sourcePath(subPath: string): string\n  packageManager: PackageManager.PackageManager\n}",
              "nodeFullText": "{\n  /**\n   * Property that aliases all the and only the data properties, makes it\n   * easy to e.g. serialize just the data.\n   */\n  data: Data\n  projectRelative(filePath: string): string\n  sourceRelative(filePath: string): string\n  sourcePath(subPath: string): string\n  packageManager: PackageManager.PackageManager\n}"
            }
          }
        ]
      },
      "raw": {
        "typeText": "Layout",
        "nodeText": "export type Layout = Data & {\n  /**\n   * Property that aliases all the and only the data properties, makes it\n   * easy to e.g. serialize just the data.\n   */\n  data: Data\n  projectRelative(filePath: string): string\n  sourceRelative(filePath: string): string\n  sourcePath(subPath: string): string\n  packageManager: PackageManager.PackageManager\n}",
        "nodeFullText": "/**\n * Layout represents the important edges of the project to support things like\n * scaffolding, build, and dev against the correct paths.\n */\nexport type Layout = Data & {\n  /**\n   * Property that aliases all the and only the data properties, makes it\n   * easy to e.g. serialize just the data.\n   */\n  data: Data\n  projectRelative(filePath: string): string\n  sourceRelative(filePath: string): string\n  sourcePath(subPath: string): string\n  packageManager: PackageManager.PackageManager\n}"
      }
    },
    "(framework/layout/layout).ScanResult": {
      "kind": "alias",
      "name": "ScanResult",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "app",
            "type": {
              "kind": "union",
              "isDiscriminated": true,
              "discriminantProperties": ["exists", "path"],
              "raw": {
                "typeText": "{ exists: true; path: string; } | { exists: false; path: null; }",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "object",
                  "props": [
                    {
                      "kind": "prop",
                      "name": "exists",
                      "type": {
                        "kind": "literal",
                        "name": "true",
                        "base": "boolean"
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "path",
                      "type": {
                        "kind": "primitive",
                        "type": "string"
                      }
                    }
                  ],
                  "raw": {
                    "typeText": "{ exists: true; path: string; }",
                    "nodeText": "{\n        exists: true\n        path: string\n      }",
                    "nodeFullText": "{\n        exists: true\n        path: string\n      }"
                  }
                },
                {
                  "kind": "object",
                  "props": [
                    {
                      "kind": "prop",
                      "name": "exists",
                      "type": {
                        "kind": "literal",
                        "name": "false",
                        "base": "boolean"
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "path",
                      "type": {
                        "kind": "primitive",
                        "type": "null"
                      }
                    }
                  ],
                  "raw": {
                    "typeText": "{ exists: false; path: null; }",
                    "nodeText": "{\n        exists: false\n        path: null\n      }",
                    "nodeFullText": "{\n        exists: false\n        path: null\n      }"
                  }
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "project",
            "type": {
              "kind": "object",
              "props": [
                {
                  "kind": "prop",
                  "name": "name",
                  "type": {
                    "kind": "primitive",
                    "type": "string"
                  }
                },
                {
                  "kind": "prop",
                  "name": "isAnonymous",
                  "type": {
                    "kind": "primitive",
                    "type": "boolean"
                  }
                }
              ],
              "raw": {
                "typeText": "{ name: string; isAnonymous: boolean; }",
                "nodeText": "{\n    name: string\n    isAnonymous: boolean\n  }",
                "nodeFullText": "{\n    name: string\n    isAnonymous: boolean\n  }"
              }
            }
          },
          {
            "kind": "prop",
            "name": "sourceRoot",
            "type": {
              "kind": "primitive",
              "type": "string"
            }
          },
          {
            "kind": "prop",
            "name": "sourceRootRelative",
            "type": {
              "kind": "primitive",
              "type": "string"
            }
          },
          {
            "kind": "prop",
            "name": "projectRoot",
            "type": {
              "kind": "primitive",
              "type": "string"
            }
          },
          {
            "kind": "prop",
            "name": "schemaModules",
            "type": {
              "kind": "array",
              "innerType": {
                "kind": "primitive",
                "type": "string"
              }
            }
          },
          {
            "kind": "prop",
            "name": "packageManagerType",
            "type": {
              "kind": "typeIndexRef",
              "link": "(utils/package-manager).PackageManagerType"
            }
          }
        ],
        "raw": {
          "typeText": "ScanResult",
          "nodeText": "export type ScanResult = {\n  // build: {\n  //   dir: string\n  // }\n  // source: {\n  //   isNested: string\n  // }\n  app:\n    | {\n        exists: true\n        path: string\n      }\n    | {\n        exists: false\n        path: null\n      }\n  project: {\n    name: string\n    isAnonymous: boolean\n  }\n  sourceRoot: string\n  sourceRootRelative: string\n  projectRoot: string\n  schemaModules: string[]\n  packageManagerType: PackageManager.PackageManager['type']\n  // schema:\n  //   | {\n  //       exists: boolean\n  //       multiple: true\n  //       paths: string[]\n  //     }\n  //   | {\n  //       exists: boolean\n  //       multiple: false\n  //       path: null | string\n  //     }\n  // context: {\n  //   exists: boolean\n  //   path: null | string\n  // }\n}",
          "nodeFullText": "/**\n * The part of layout data resulting from the dynamic file/folder inspection.\n */\nexport type ScanResult = {\n  // build: {\n  //   dir: string\n  // }\n  // source: {\n  //   isNested: string\n  // }\n  app:\n    | {\n        exists: true\n        path: string\n      }\n    | {\n        exists: false\n        path: null\n      }\n  project: {\n    name: string\n    isAnonymous: boolean\n  }\n  sourceRoot: string\n  sourceRootRelative: string\n  projectRoot: string\n  schemaModules: string[]\n  packageManagerType: PackageManager.PackageManager['type']\n  // schema:\n  //   | {\n  //       exists: boolean\n  //       multiple: true\n  //       paths: string[]\n  //     }\n  //   | {\n  //       exists: boolean\n  //       multiple: false\n  //       path: null | string\n  //     }\n  // context: {\n  //   exists: boolean\n  //   path: null | string\n  // }\n}"
        }
      },
      "raw": {
        "typeText": "ScanResult",
        "nodeText": "export type ScanResult = {\n  // build: {\n  //   dir: string\n  // }\n  // source: {\n  //   isNested: string\n  // }\n  app:\n    | {\n        exists: true\n        path: string\n      }\n    | {\n        exists: false\n        path: null\n      }\n  project: {\n    name: string\n    isAnonymous: boolean\n  }\n  sourceRoot: string\n  sourceRootRelative: string\n  projectRoot: string\n  schemaModules: string[]\n  packageManagerType: PackageManager.PackageManager['type']\n  // schema:\n  //   | {\n  //       exists: boolean\n  //       multiple: true\n  //       paths: string[]\n  //     }\n  //   | {\n  //       exists: boolean\n  //       multiple: false\n  //       path: null | string\n  //     }\n  // context: {\n  //   exists: boolean\n  //   path: null | string\n  // }\n}",
        "nodeFullText": "/**\n * The part of layout data resulting from the dynamic file/folder inspection.\n */\nexport type ScanResult = {\n  // build: {\n  //   dir: string\n  // }\n  // source: {\n  //   isNested: string\n  // }\n  app:\n    | {\n        exists: true\n        path: string\n      }\n    | {\n        exists: false\n        path: null\n      }\n  project: {\n    name: string\n    isAnonymous: boolean\n  }\n  sourceRoot: string\n  sourceRootRelative: string\n  projectRoot: string\n  schemaModules: string[]\n  packageManagerType: PackageManager.PackageManager['type']\n  // schema:\n  //   | {\n  //       exists: boolean\n  //       multiple: true\n  //       paths: string[]\n  //     }\n  //   | {\n  //       exists: boolean\n  //       multiple: false\n  //       path: null | string\n  //     }\n  // context: {\n  //   exists: boolean\n  //   path: null | string\n  // }\n}"
      }
    },
    "(utils/package-manager).PackageManagerType": {
      "kind": "alias",
      "name": "PackageManagerType",
      "type": {
        "kind": "union",
        "isDiscriminated": false,
        "discriminantProperties": null,
        "raw": {
          "typeText": "PackageManagerType",
          "nodeText": "export type PackageManagerType = 'yarn' | 'npm'",
          "nodeFullText": "export type PackageManagerType = 'yarn' | 'npm'"
        },
        "types": [
          {
            "kind": "literal",
            "name": "\"yarn\"",
            "base": "string"
          },
          {
            "kind": "literal",
            "name": "\"npm\"",
            "base": "string"
          }
        ]
      },
      "raw": {
        "typeText": "PackageManagerType",
        "nodeText": "export type PackageManagerType = 'yarn' | 'npm'",
        "nodeFullText": "export type PackageManagerType = 'yarn' | 'npm'"
      }
    },
    "(framework/layout/layout).Data": {
      "kind": "alias",
      "name": "Data",
      "type": {
        "kind": "intersection",
        "raw": {
          "typeText": "Data",
          "nodeText": "export type Data = ScanResult & {\n  buildOutput: string\n}",
          "nodeFullText": "/**\n * The combination of manual datums the user can specify about the layout plus\n * the dynamic scan results.\n */\nexport type Data = ScanResult & {\n  buildOutput: string\n}"
        },
        "types": [
          {
            "kind": "typeIndexRef",
            "link": "(framework/layout/layout).ScanResult"
          },
          {
            "kind": "object",
            "props": [
              {
                "kind": "prop",
                "name": "buildOutput",
                "type": {
                  "kind": "primitive",
                  "type": "string"
                }
              }
            ],
            "raw": {
              "typeText": "{ buildOutput: string; }",
              "nodeText": "{\n  buildOutput: string\n}",
              "nodeFullText": "{\n  buildOutput: string\n}"
            }
          }
        ]
      },
      "raw": {
        "typeText": "Data",
        "nodeText": "export type Data = ScanResult & {\n  buildOutput: string\n}",
        "nodeFullText": "/**\n * The combination of manual datums the user can specify about the layout plus\n * the dynamic scan results.\n */\nexport type Data = ScanResult & {\n  buildOutput: string\n}"
      }
    },
    "(utils/package-manager).PackageManager": {
      "kind": "alias",
      "name": "PackageManager",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "type",
            "type": {
              "kind": "typeIndexRef",
              "link": "(utils/package-manager).PackageManagerType"
            }
          },
          {
            "kind": "prop",
            "name": "installDeps",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "unsupported",
                    "raw": {
                      "typeText": "Promise<SuccessfulRunResult>",
                      "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                      "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                    }
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "args",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Args",
                          "nodeText": "Args",
                          "nodeFullText": "Args"
                        }
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(options?: RunOptions | undefined) => Promise<SuccessfulRunResult>",
                "nodeText": "(...args: Args) => Ret",
                "nodeFullText": "(...args: Args) => Ret"
              }
            }
          },
          {
            "kind": "prop",
            "name": "addDeps",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "unsupported",
                    "raw": {
                      "typeText": "Promise<SuccessfulRunResult>",
                      "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                      "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                    }
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "args",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Args",
                          "nodeText": "Args",
                          "nodeFullText": "Args"
                        }
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(packages: string[], options?: AddDepsOptions | undefined) => Promise<SuccessfulRunResult>",
                "nodeText": "(...args: Args) => Ret",
                "nodeFullText": "(...args: Args) => Ret"
              }
            }
          },
          {
            "kind": "prop",
            "name": "runBin",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "unsupported",
                    "raw": {
                      "typeText": "Promise<SuccessfulRunResult>",
                      "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                      "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                    }
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "args",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Args",
                          "nodeText": "Args",
                          "nodeFullText": "Args"
                        }
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(commandString: string, options?: RunOptions | undefined) => Promise<SuccessfulRunResult>",
                "nodeText": "(...args: Args) => Ret",
                "nodeFullText": "(...args: Args) => Ret"
              }
            }
          },
          {
            "kind": "prop",
            "name": "runScript",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "unsupported",
                    "raw": {
                      "typeText": "Promise<SuccessfulRunResult>",
                      "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                      "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                    }
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "args",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Args",
                          "nodeText": "Args",
                          "nodeFullText": "Args"
                        }
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(scriptName: string, options?: RunOptions | undefined) => Promise<SuccessfulRunResult>",
                "nodeText": "(...args: Args) => Ret",
                "nodeFullText": "(...args: Args) => Ret"
              }
            }
          },
          {
            "kind": "prop",
            "name": "renderRunBin",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "primitive",
                    "type": "string"
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "args",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Args",
                          "nodeText": "Args",
                          "nodeFullText": "Args"
                        }
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(commandString: string) => string",
                "nodeText": "(...args: Args) => Ret",
                "nodeFullText": "(...args: Args) => Ret"
              }
            }
          },
          {
            "kind": "prop",
            "name": "renderRunScript",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "primitive",
                    "type": "string"
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "args",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Args",
                          "nodeText": "Args",
                          "nodeFullText": "Args"
                        }
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(scriptName: string) => string",
                "nodeText": "(...args: Args) => Ret",
                "nodeFullText": "(...args: Args) => Ret"
              }
            }
          },
          {
            "kind": "prop",
            "name": "renderAddDeps",
            "type": {
              "kind": "callable",
              "isOverloaded": false,
              "hasProps": false,
              "props": [],
              "sigs": [
                {
                  "kind": "sig",
                  "return": {
                    "kind": "primitive",
                    "type": "string"
                  },
                  "params": [
                    {
                      "kind": "sigParam",
                      "name": "args",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Args",
                          "nodeText": "Args",
                          "nodeFullText": "Args"
                        }
                      }
                    }
                  ]
                }
              ],
              "raw": {
                "typeText": "(packages: string[], options?: { dev?: boolean | undefined; } | undefined) => string",
                "nodeText": "(...args: Args) => Ret",
                "nodeFullText": "(...args: Args) => Ret"
              }
            }
          }
        ],
        "raw": {
          "typeText": "PackageManager",
          "nodeText": "export type PackageManager = {\n  type: PackageManagerType\n  installDeps: OmitFirstArg<typeof installDeps>\n  addDeps: OmitFirstArg<typeof addDeps>\n  runBin: OmitFirstArg<typeof runBin>\n  runScript: OmitFirstArg<typeof runScript>\n  renderRunBin: OmitFirstArg<typeof renderRunBin>\n  renderRunScript: OmitFirstArg<typeof renderRunScript>\n  renderAddDeps: OmitFirstArg<typeof renderAddDeps>\n}",
          "nodeFullText": "//\n// Fluent API\n//\n\n/**\n * The package manager as a fluent API, all statics partially applied with the\n * package manager type.\n */\nexport type PackageManager = {\n  type: PackageManagerType\n  installDeps: OmitFirstArg<typeof installDeps>\n  addDeps: OmitFirstArg<typeof addDeps>\n  runBin: OmitFirstArg<typeof runBin>\n  runScript: OmitFirstArg<typeof runScript>\n  renderRunBin: OmitFirstArg<typeof renderRunBin>\n  renderRunScript: OmitFirstArg<typeof renderRunScript>\n  renderAddDeps: OmitFirstArg<typeof renderAddDeps>\n}"
        }
      },
      "raw": {
        "typeText": "PackageManager",
        "nodeText": "export type PackageManager = {\n  type: PackageManagerType\n  installDeps: OmitFirstArg<typeof installDeps>\n  addDeps: OmitFirstArg<typeof addDeps>\n  runBin: OmitFirstArg<typeof runBin>\n  runScript: OmitFirstArg<typeof runScript>\n  renderRunBin: OmitFirstArg<typeof renderRunBin>\n  renderRunScript: OmitFirstArg<typeof renderRunScript>\n  renderAddDeps: OmitFirstArg<typeof renderAddDeps>\n}",
        "nodeFullText": "//\n// Fluent API\n//\n\n/**\n * The package manager as a fluent API, all statics partially applied with the\n * package manager type.\n */\nexport type PackageManager = {\n  type: PackageManagerType\n  installDeps: OmitFirstArg<typeof installDeps>\n  addDeps: OmitFirstArg<typeof addDeps>\n  runBin: OmitFirstArg<typeof runBin>\n  runScript: OmitFirstArg<typeof runScript>\n  renderRunBin: OmitFirstArg<typeof renderRunBin>\n  renderRunScript: OmitFirstArg<typeof renderRunScript>\n  renderAddDeps: OmitFirstArg<typeof renderAddDeps>\n}"
      }
    },
    "(core/plugin/index).RuntimeContributions": {
      "kind": "alias",
      "name": "RuntimeContributions",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "context",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "{ typeGen: { fields: Record<string, string>; imports?: { as: string; from: string; }[] | undefined; }; create: (req: Request) => C; } | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "object",
                  "props": [
                    {
                      "kind": "prop",
                      "name": "typeGen",
                      "type": {
                        "kind": "object",
                        "props": [
                          {
                            "kind": "prop",
                            "name": "fields",
                            "type": {
                              "kind": "unsupported",
                              "raw": {
                                "typeText": "Record<string, string>",
                                "nodeText": "type Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};",
                                "nodeFullText": "/**\r\n * Construct a type with a set of properties K of type T\r\n */\r\ntype Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};"
                              }
                            }
                          },
                          {
                            "kind": "prop",
                            "name": "imports",
                            "type": {
                              "kind": "union",
                              "isDiscriminated": false,
                              "discriminantProperties": null,
                              "raw": {
                                "typeText": "{ as: string; from: string; }[] | undefined",
                                "nodeFullText": "",
                                "nodeText": ""
                              },
                              "types": [
                                {
                                  "kind": "primitive",
                                  "type": "undefined"
                                },
                                {
                                  "kind": "array",
                                  "innerType": {
                                    "kind": "object",
                                    "props": [
                                      {
                                        "kind": "prop",
                                        "name": "as",
                                        "type": {
                                          "kind": "primitive",
                                          "type": "string"
                                        }
                                      },
                                      {
                                        "kind": "prop",
                                        "name": "from",
                                        "type": {
                                          "kind": "primitive",
                                          "type": "string"
                                        }
                                      }
                                    ],
                                    "raw": {
                                      "typeText": "{ as: string; from: string; }",
                                      "nodeText": "{\n        as: string\n        from: string\n      }",
                                      "nodeFullText": "{\n        as: string\n        from: string\n      }"
                                    }
                                  }
                                }
                              ]
                            }
                          }
                        ],
                        "raw": {
                          "typeText": "{ fields: Record<string, string>; imports?: { as: string; from: string; }[] | undefined; }",
                          "nodeText": "{\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }",
                          "nodeFullText": "{\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }"
                        }
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "create",
                      "type": {
                        "kind": "callable",
                        "isOverloaded": false,
                        "hasProps": false,
                        "props": [],
                        "sigs": [
                          {
                            "kind": "sig",
                            "return": {
                              "kind": "unsupported",
                              "raw": {
                                "typeText": "C",
                                "nodeText": "C extends {} = any",
                                "nodeFullText": "C extends {} = any"
                              }
                            },
                            "params": [
                              {
                                "kind": "sigParam",
                                "name": "req",
                                "type": {
                                  "kind": "unsupported",
                                  "raw": {
                                    "typeText": "Request",
                                    "nodeText": "interface Request { }",
                                    "nodeFullText": "// These open interfaces may be extended in an application-specific manner via declaration merging.\n        // See for example method-override.d.ts (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/method-override/index.d.ts)\n        interface Request { }"
                                  }
                                }
                              }
                            ]
                          }
                        ],
                        "raw": {
                          "typeText": "(req: Request) => C",
                          "nodeText": "(req: Express.Request) => C",
                          "nodeFullText": "(req: Express.Request) => C"
                        }
                      }
                    }
                  ],
                  "raw": {
                    "typeText": "{ typeGen: { fields: Record<string, string>; imports?: { as: string; from: string; }[] | undefined; }; create: (req: Request) => C; }",
                    "nodeText": "{\n    typeGen: {\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }\n    create: (req: Express.Request) => C\n  }",
                    "nodeFullText": "{\n    typeGen: {\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }\n    create: (req: Express.Request) => C\n  }"
                  }
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "nexus",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "{ typegenAutoConfig?: TypegenAutoConfigOptions | undefined; plugins?: NexusPlugin[] | undefined; } | undefined",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "undefined"
                },
                {
                  "kind": "object",
                  "props": [
                    {
                      "kind": "prop",
                      "name": "typegenAutoConfig",
                      "type": {
                        "kind": "union",
                        "isDiscriminated": false,
                        "discriminantProperties": null,
                        "raw": {
                          "typeText": "TypegenAutoConfigOptions | undefined",
                          "nodeFullText": "",
                          "nodeText": ""
                        },
                        "types": [
                          {
                            "kind": "primitive",
                            "type": "undefined"
                          },
                          {
                            "kind": "unsupported",
                            "raw": {
                              "typeText": "TypegenAutoConfigOptions",
                              "nodeText": "export interface TypegenAutoConfigOptions {\n    /**\n     * Any headers to prefix on the generated type file\n     */\n    headers?: string[];\n    /**\n     * Array of TypegenConfigSourceModule's to look in and match the type names against.\n     *\n     * ```\n     * sources: [\n     *   { source: 'typescript', alias: 'ts' },\n     *   { source: path.join(__dirname, '../backingTypes'), alias: 'b' },\n     * ]\n     * ```\n     */\n    sources: TypegenConfigSourceModule[];\n    /**\n     * Typing for the context, referencing a type defined in the aliased module\n     * provided in sources e.g. `alias.Context`\n     */\n    contextType?: string;\n    /**\n     * Types that should not be matched for a backing type,\n     *\n     * By default this is set to ['Query', 'Mutation', 'Subscription']\n     *\n     * ```\n     * skipTypes: ['Query', 'Mutation', /(.*?)Edge/, /(.*?)Connection/]\n     * ```\n     */\n    skipTypes?: (string | RegExp)[];\n    /**\n     * If debug is set to true, this will log out info about all types\n     * found, skipped, etc. for the type generation files.\n     */\n    debug?: boolean;\n    /**\n     * If provided this will be used for the backing types rather than the auto-resolve\n     * mechanism above. Useful as an override for one-off cases, or for scalar\n     * backing types.\n     */\n    backingTypeMap?: Record<string, string>;\n}",
                              "nodeFullText": "export interface TypegenAutoConfigOptions {\n    /**\n     * Any headers to prefix on the generated type file\n     */\n    headers?: string[];\n    /**\n     * Array of TypegenConfigSourceModule's to look in and match the type names against.\n     *\n     * ```\n     * sources: [\n     *   { source: 'typescript', alias: 'ts' },\n     *   { source: path.join(__dirname, '../backingTypes'), alias: 'b' },\n     * ]\n     * ```\n     */\n    sources: TypegenConfigSourceModule[];\n    /**\n     * Typing for the context, referencing a type defined in the aliased module\n     * provided in sources e.g. `alias.Context`\n     */\n    contextType?: string;\n    /**\n     * Types that should not be matched for a backing type,\n     *\n     * By default this is set to ['Query', 'Mutation', 'Subscription']\n     *\n     * ```\n     * skipTypes: ['Query', 'Mutation', /(.*?)Edge/, /(.*?)Connection/]\n     * ```\n     */\n    skipTypes?: (string | RegExp)[];\n    /**\n     * If debug is set to true, this will log out info about all types\n     * found, skipped, etc. for the type generation files.\n     */\n    debug?: boolean;\n    /**\n     * If provided this will be used for the backing types rather than the auto-resolve\n     * mechanism above. Useful as an override for one-off cases, or for scalar\n     * backing types.\n     */\n    backingTypeMap?: Record<string, string>;\n}"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "kind": "prop",
                      "name": "plugins",
                      "type": {
                        "kind": "union",
                        "isDiscriminated": false,
                        "discriminantProperties": null,
                        "raw": {
                          "typeText": "NexusPlugin[] | undefined",
                          "nodeFullText": "",
                          "nodeText": ""
                        },
                        "types": [
                          {
                            "kind": "primitive",
                            "type": "undefined"
                          },
                          {
                            "kind": "array",
                            "innerType": {
                              "kind": "unsupported",
                              "raw": {
                                "typeText": "NexusPlugin",
                                "nodeText": "export declare class NexusPlugin {\n    readonly config: PluginConfig;\n    constructor(config: PluginConfig);\n}",
                                "nodeFullText": "/**\n * A definition for a plugin. Should be passed to the `plugins: []` option\n * on makeSchema\n */\nexport declare class NexusPlugin {\n    readonly config: PluginConfig;\n    constructor(config: PluginConfig);\n}"
                              }
                            }
                          }
                        ]
                      }
                    }
                  ],
                  "raw": {
                    "typeText": "{ typegenAutoConfig?: TypegenAutoConfigOptions | undefined; plugins?: NexusPlugin[] | undefined; }",
                    "nodeText": "{\n    typegenAutoConfig?: NexusSchema.core.SchemaConfig['typegenAutoConfig']\n    plugins?: NexusSchema.core.SchemaConfig['plugins']\n  }",
                    "nodeFullText": "{\n    typegenAutoConfig?: NexusSchema.core.SchemaConfig['typegenAutoConfig']\n    plugins?: NexusSchema.core.SchemaConfig['plugins']\n  }"
                  }
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "RuntimeContributions<any>",
          "nodeText": "export type RuntimeContributions<C extends {} = any> = {\n  context?: {\n    typeGen: {\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }\n    create: (req: Express.Request) => C\n  }\n  // todo schema property name\n  nexus?: {\n    typegenAutoConfig?: NexusSchema.core.SchemaConfig['typegenAutoConfig']\n    plugins?: NexusSchema.core.SchemaConfig['plugins']\n  }\n}",
          "nodeFullText": "/**\n * The possible things that plugins can contribute toward at runtime. Everything\n * is optional.\n */\nexport type RuntimeContributions<C extends {} = any> = {\n  context?: {\n    typeGen: {\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }\n    create: (req: Express.Request) => C\n  }\n  // todo schema property name\n  nexus?: {\n    typegenAutoConfig?: NexusSchema.core.SchemaConfig['typegenAutoConfig']\n    plugins?: NexusSchema.core.SchemaConfig['plugins']\n  }\n}"
        }
      },
      "raw": {
        "typeText": "RuntimeContributions<any>",
        "nodeText": "export type RuntimeContributions<C extends {} = any> = {\n  context?: {\n    typeGen: {\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }\n    create: (req: Express.Request) => C\n  }\n  // todo schema property name\n  nexus?: {\n    typegenAutoConfig?: NexusSchema.core.SchemaConfig['typegenAutoConfig']\n    plugins?: NexusSchema.core.SchemaConfig['plugins']\n  }\n}",
        "nodeFullText": "/**\n * The possible things that plugins can contribute toward at runtime. Everything\n * is optional.\n */\nexport type RuntimeContributions<C extends {} = any> = {\n  context?: {\n    typeGen: {\n      fields: Record<string, string>\n      imports?: Array<{\n        as: string\n        from: string\n      }>\n    }\n    create: (req: Express.Request) => C\n  }\n  // todo schema property name\n  nexus?: {\n    typegenAutoConfig?: NexusSchema.core.SchemaConfig['typegenAutoConfig']\n    plugins?: NexusSchema.core.SchemaConfig['plugins']\n  }\n}"
      }
    },
    "(lib/utils/index).DeepPartial": {
      "kind": "alias",
      "name": "DeepPartial",
      "type": {
        "kind": "intersection",
        "raw": {
          "typeText": "DeepPartial<TestContextCore>",
          "nodeText": "export type DeepPartial<T extends Record<string, any>> = {\n  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]\n} & { [x: string]: any }",
          "nodeFullText": "export type DeepPartial<T extends Record<string, any>> = {\n  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]\n} & { [x: string]: any }"
        },
        "types": [
          {
            "kind": "object",
            "props": [
              {
                "kind": "prop",
                "name": "app",
                "type": {
                  "kind": "typeIndexRef",
                  "link": "(framework/testing).TestContextAppCore"
                }
              }
            ],
            "raw": {
              "typeText": "{ app?: DeepPartial<TestContextAppCore> | undefined; }",
              "nodeText": "{\n  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]\n}",
              "nodeFullText": "{\n  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]\n}"
            }
          },
          {
            "kind": "object",
            "props": [],
            "raw": {
              "typeText": "{ [x: string]: any; }",
              "nodeText": "{ [x: string]: any }",
              "nodeFullText": "{ [x: string]: any }"
            }
          }
        ]
      },
      "raw": {
        "typeText": "DeepPartial<TestContextCore>",
        "nodeText": "export type DeepPartial<T extends Record<string, any>> = {\n  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]\n} & { [x: string]: any }",
        "nodeFullText": "export type DeepPartial<T extends Record<string, any>> = {\n  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]\n} & { [x: string]: any }"
      }
    },
    "(framework/testing).TestContextAppCore": {
      "kind": "interface",
      "name": "TestContextAppCore",
      "props": [
        {
          "kind": "prop",
          "name": "query",
          "type": {
            "kind": "unsupported",
            "raw": {
              "typeText": "<T extends any>(query: string, variables?: Variables | undefined) => Promise<T>",
              "nodeText": "request<T extends any>(query: string, variables?: Variables): Promise<T>;",
              "nodeFullText": "request<T extends any>(query: string, variables?: Variables): Promise<T>;"
            }
          }
        },
        {
          "kind": "prop",
          "name": "server",
          "type": {
            "kind": "object",
            "props": [
              {
                "kind": "prop",
                "name": "start",
                "type": {
                  "kind": "callable",
                  "isOverloaded": false,
                  "hasProps": false,
                  "props": [],
                  "sigs": [
                    {
                      "kind": "sig",
                      "return": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Promise<void>",
                          "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                          "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                        }
                      },
                      "params": []
                    }
                  ],
                  "raw": {
                    "typeText": "() => Promise<void>",
                    "nodeText": "() => Promise<void>",
                    "nodeFullText": "() => Promise<void>"
                  }
                }
              },
              {
                "kind": "prop",
                "name": "stop",
                "type": {
                  "kind": "callable",
                  "isOverloaded": false,
                  "hasProps": false,
                  "props": [],
                  "sigs": [
                    {
                      "kind": "sig",
                      "return": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Promise<void>",
                          "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                          "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                        }
                      },
                      "params": []
                    }
                  ],
                  "raw": {
                    "typeText": "() => Promise<void>",
                    "nodeText": "() => Promise<void>",
                    "nodeFullText": "() => Promise<void>"
                  }
                }
              }
            ],
            "raw": {
              "typeText": "{ start: () => Promise<void>; stop: () => Promise<void>; }",
              "nodeText": "{\n    start: () => Promise<void>\n    stop: () => Promise<void>\n  }",
              "nodeFullText": "{\n    start: () => Promise<void>\n    stop: () => Promise<void>\n  }"
            }
          }
        }
      ],
      "jsdoc": null,
      "raw": {
        "typeText": "TestContextAppCore",
        "nodeText": "export interface TestContextAppCore {\n  query: AppClient['query']\n  server: {\n    start: () => Promise<void>\n    stop: () => Promise<void>\n  }\n}",
        "nodeFullText": "export interface TestContextAppCore {\n  query: AppClient['query']\n  server: {\n    start: () => Promise<void>\n    stop: () => Promise<void>\n  }\n}"
      }
    },
    "(core/plugin/index).Definer": {
      "kind": "alias",
      "name": "Definer",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "primitive",
              "type": "void"
            },
            "params": [
              {
                "kind": "sigParam",
                "name": "lens",
                "type": {
                  "kind": "typeIndexRef",
                  "link": "(core/plugin/index).Lens"
                }
              }
            ]
          }
        ],
        "raw": {
          "typeText": "Definer",
          "nodeText": "type Definer = (lens: Lens) => void",
          "nodeFullText": "type Definer = (lens: Lens) => void"
        }
      },
      "raw": {
        "typeText": "Definer",
        "nodeText": "type Definer = (lens: Lens) => void",
        "nodeFullText": "type Definer = (lens: Lens) => void"
      }
    },
    "(core/plugin/index).Lens": {
      "kind": "alias",
      "name": "Lens",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "runtime",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/utils/index).CallbackRegistrer"
            }
          },
          {
            "kind": "prop",
            "name": "workflow",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/utils/index).CallbackRegistrer"
            }
          },
          {
            "kind": "prop",
            "name": "testing",
            "type": {
              "kind": "typeIndexRef",
              "link": "(lib/utils/index).CallbackRegistrer"
            }
          },
          {
            "kind": "prop",
            "name": "utils",
            "type": {
              "kind": "object",
              "props": [
                {
                  "kind": "prop",
                  "name": "log",
                  "type": {
                    "kind": "typeIndexRef",
                    "link": "(lib/logger/logger).Logger"
                  }
                },
                {
                  "kind": "prop",
                  "name": "runSync",
                  "type": {
                    "kind": "callable",
                    "isOverloaded": false,
                    "hasProps": false,
                    "props": [],
                    "sigs": [
                      {
                        "kind": "sig",
                        "return": {
                          "kind": "typeIndexRef",
                          "link": "(utils/process).SuccessfulRunResult"
                        },
                        "params": [
                          {
                            "kind": "sigParam",
                            "name": "commandRaw",
                            "type": {
                              "kind": "primitive",
                              "type": "string"
                            }
                          },
                          {
                            "kind": "sigParam",
                            "name": "options",
                            "type": {
                              "kind": "union",
                              "isDiscriminated": false,
                              "discriminantProperties": null,
                              "raw": {
                                "typeText": "RunOptions | undefined",
                                "nodeFullText": "",
                                "nodeText": ""
                              },
                              "types": [
                                {
                                  "kind": "primitive",
                                  "type": "undefined"
                                },
                                {
                                  "kind": "alias",
                                  "name": "RunOptions",
                                  "type": {
                                    "kind": "typeIndexRef",
                                    "link": "(utils/process).RunOptions"
                                  },
                                  "raw": {
                                    "typeText": "RunOptions",
                                    "nodeText": "export type RunOptions = Omit<SpawnSyncOptions, 'encoding'> & {\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}",
                                    "nodeFullText": "// TODO should not use sync options type for async run\nexport type RunOptions = Omit<SpawnSyncOptions, 'encoding'> & {\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    ],
                    "raw": {
                      "typeText": "(commandRaw: string, options?: RunOptions | undefined) => SuccessfulRunResult",
                      "nodeText": "export function runSync(\n  commandRaw: string,\n  options?: RunOptions\n): SuccessfulRunResult {\n  const command = parseCommandString(commandRaw)\n  const env = options?.envAdditions\n    ? { ...process.env, ...options.envAdditions }\n    : process.env\n  const { stderr, stdout, status: exitCode, signal } = spawnSync(\n    command.name,\n    command.args,\n    {\n      ...options,\n      encoding: 'utf8',\n      env,\n    }\n  )\n\n  const error = isFailedExitCode(exitCode)\n    ? createCommandError({\n        command: commandRaw,\n        underlyingError: null,\n        stderr,\n        stdout,\n        exitCode,\n        signal,\n      })\n    : null\n\n  if (error && options?.require === true) {\n    throw error\n  } else {\n    return { command: commandRaw, stderr, stdout, exitCode, signal, error }\n  }\n}",
                      "nodeFullText": "// TODO conditional type over require option\nexport function runSync(\n  commandRaw: string,\n  options?: RunOptions\n): SuccessfulRunResult {\n  const command = parseCommandString(commandRaw)\n  const env = options?.envAdditions\n    ? { ...process.env, ...options.envAdditions }\n    : process.env\n  const { stderr, stdout, status: exitCode, signal } = spawnSync(\n    command.name,\n    command.args,\n    {\n      ...options,\n      encoding: 'utf8',\n      env,\n    }\n  )\n\n  const error = isFailedExitCode(exitCode)\n    ? createCommandError({\n        command: commandRaw,\n        underlyingError: null,\n        stderr,\n        stdout,\n        exitCode,\n        signal,\n      })\n    : null\n\n  if (error && options?.require === true) {\n    throw error\n  } else {\n    return { command: commandRaw, stderr, stdout, exitCode, signal, error }\n  }\n}"
                    }
                  }
                },
                {
                  "kind": "prop",
                  "name": "run",
                  "type": {
                    "kind": "callable",
                    "isOverloaded": false,
                    "hasProps": false,
                    "props": [],
                    "sigs": [
                      {
                        "kind": "sig",
                        "return": {
                          "kind": "unsupported",
                          "raw": {
                            "typeText": "Promise<SuccessfulRunResult>",
                            "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                            "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
                          }
                        },
                        "params": [
                          {
                            "kind": "sigParam",
                            "name": "commandRaw",
                            "type": {
                              "kind": "primitive",
                              "type": "string"
                            }
                          },
                          {
                            "kind": "sigParam",
                            "name": "options",
                            "type": {
                              "kind": "union",
                              "isDiscriminated": false,
                              "discriminantProperties": null,
                              "raw": {
                                "typeText": "RunOptions | undefined",
                                "nodeFullText": "",
                                "nodeText": ""
                              },
                              "types": [
                                {
                                  "kind": "primitive",
                                  "type": "undefined"
                                },
                                {
                                  "kind": "alias",
                                  "name": "RunOptions",
                                  "type": {
                                    "kind": "typeIndexRef",
                                    "link": "(utils/process).RunOptions"
                                  },
                                  "raw": {
                                    "typeText": "RunOptions",
                                    "nodeText": "export type RunOptions = Omit<SpawnSyncOptions, 'encoding'> & {\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}",
                                    "nodeFullText": "// TODO should not use sync options type for async run\nexport type RunOptions = Omit<SpawnSyncOptions, 'encoding'> & {\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    ],
                    "raw": {
                      "typeText": "(commandRaw: string, options?: RunOptions | undefined) => Promise<SuccessfulRunResult>",
                      "nodeText": "export async function run(\n  commandRaw: string,\n  options?: RunOptions\n): Promise<SuccessfulRunResult> {\n  const command = parseCommandString(commandRaw)\n  const env = options?.envAdditions\n    ? { ...process.env, ...options.envAdditions }\n    : process.env\n\n  const child = spawn(command.name, command.args, {\n    ...options,\n    env,\n  })\n\n  // TODO use proper signal typing, see child exit cb types\n  const result = await new Promise<SuccessfulRunResult>((resolve, reject) => {\n    // NOTE \"exit\" may fire after \"error\", in which case it will be a noop\n    // as per how promises work.\n\n    // When spawn is executed in pipe mode, then we buffer up the data for\n    // later inspection\n    // TODO return type should use conditional types to express mapping\n    // between stdio option settings and resulting returned std err/out buffers.\n    let stderr: null | string = null\n    let stdout: null | string = null\n\n    if (child.stderr) {\n      stderr = ''\n      child.stderr.on('data', bufferStderr)\n    }\n\n    if (child.stdout) {\n      stdout = ''\n      child.stdout.on('data', bufferStdout)\n    }\n\n    function bufferStderr(chunk: any) {\n      stderr += String(chunk)\n    }\n\n    function bufferStdout(chunk: any) {\n      stdout += String(chunk)\n    }\n\n    child.once('error', error => {\n      const richError = createCommandError({\n        command: commandRaw,\n        underlyingError: error,\n        stderr,\n        stdout,\n        signal: null,\n        exitCode: null,\n      })\n\n      if (options?.require === true) {\n        cleanup()\n        reject(richError)\n      } else {\n        cleanup()\n        resolve({\n          command: commandRaw,\n          stdout,\n          stderr,\n          signal: null,\n          error: richError,\n          exitCode: null,\n        })\n      }\n    })\n\n    child.once('exit', (exitCode, signal) => {\n      const error = isFailedExitCode(exitCode)\n        ? createCommandError({\n            command: commandRaw,\n            underlyingError: null,\n            signal,\n            stderr,\n            stdout,\n            exitCode,\n          })\n        : null\n\n      if (options?.require === true && isFailedExitCode(exitCode)) {\n        cleanup()\n        reject(error)\n      } else {\n        cleanup()\n        resolve({\n          command: commandRaw,\n          signal,\n          stderr,\n          stdout,\n          exitCode,\n          error,\n        })\n      }\n    })\n\n    function cleanup() {\n      child.stderr?.removeListener('data', bufferStderr)\n      child.stdout?.removeListener('data', bufferStdout)\n    }\n  })\n\n  return result\n}",
                      "nodeFullText": "export async function run(\n  commandRaw: string,\n  options?: RunOptions\n): Promise<SuccessfulRunResult> {\n  const command = parseCommandString(commandRaw)\n  const env = options?.envAdditions\n    ? { ...process.env, ...options.envAdditions }\n    : process.env\n\n  const child = spawn(command.name, command.args, {\n    ...options,\n    env,\n  })\n\n  // TODO use proper signal typing, see child exit cb types\n  const result = await new Promise<SuccessfulRunResult>((resolve, reject) => {\n    // NOTE \"exit\" may fire after \"error\", in which case it will be a noop\n    // as per how promises work.\n\n    // When spawn is executed in pipe mode, then we buffer up the data for\n    // later inspection\n    // TODO return type should use conditional types to express mapping\n    // between stdio option settings and resulting returned std err/out buffers.\n    let stderr: null | string = null\n    let stdout: null | string = null\n\n    if (child.stderr) {\n      stderr = ''\n      child.stderr.on('data', bufferStderr)\n    }\n\n    if (child.stdout) {\n      stdout = ''\n      child.stdout.on('data', bufferStdout)\n    }\n\n    function bufferStderr(chunk: any) {\n      stderr += String(chunk)\n    }\n\n    function bufferStdout(chunk: any) {\n      stdout += String(chunk)\n    }\n\n    child.once('error', error => {\n      const richError = createCommandError({\n        command: commandRaw,\n        underlyingError: error,\n        stderr,\n        stdout,\n        signal: null,\n        exitCode: null,\n      })\n\n      if (options?.require === true) {\n        cleanup()\n        reject(richError)\n      } else {\n        cleanup()\n        resolve({\n          command: commandRaw,\n          stdout,\n          stderr,\n          signal: null,\n          error: richError,\n          exitCode: null,\n        })\n      }\n    })\n\n    child.once('exit', (exitCode, signal) => {\n      const error = isFailedExitCode(exitCode)\n        ? createCommandError({\n            command: commandRaw,\n            underlyingError: null,\n            signal,\n            stderr,\n            stdout,\n            exitCode,\n          })\n        : null\n\n      if (options?.require === true && isFailedExitCode(exitCode)) {\n        cleanup()\n        reject(error)\n      } else {\n        cleanup()\n        resolve({\n          command: commandRaw,\n          signal,\n          stderr,\n          stdout,\n          exitCode,\n          error,\n        })\n      }\n    })\n\n    function cleanup() {\n      child.stderr?.removeListener('data', bufferStderr)\n      child.stdout?.removeListener('data', bufferStdout)\n    }\n  })\n\n  return result\n}"
                    }
                  }
                },
                {
                  "kind": "prop",
                  "name": "prompt",
                  "type": {
                    "kind": "typeIndexRef",
                    "link": "(core/plugin/index).PromptsConstructor"
                  }
                }
              ],
              "raw": {
                "typeText": "{ log: Logger; runSync: (commandRaw: string, options?: RunOptions | undefined) => SuccessfulRunResult; run: (commandRaw: string, options?: RunOptions | undefined) => Promise<...>; prompt: PromptsConstructor; }",
                "nodeText": "{\n    log: Logger.Logger\n    runSync: typeof runSync\n    run: typeof run\n    /**\n     * Check out https://github.com/terkelg/prompts for documentation\n     */\n    prompt: PromptsConstructor\n  }",
                "nodeFullText": "{\n    log: Logger.Logger\n    runSync: typeof runSync\n    run: typeof run\n    /**\n     * Check out https://github.com/terkelg/prompts for documentation\n     */\n    prompt: PromptsConstructor\n  }"
              }
            }
          }
        ],
        "raw": {
          "typeText": "Lens",
          "nodeText": "export type Lens = {\n  runtime: CallbackRegistrer<RuntimePlugin>\n  workflow: CallbackRegistrer<WorkflowDefiner>\n  testing: CallbackRegistrer<TestingPlugin>\n  utils: {\n    log: Logger.Logger\n    runSync: typeof runSync\n    run: typeof run\n    /**\n     * Check out https://github.com/terkelg/prompts for documentation\n     */\n    prompt: PromptsConstructor\n  }\n}",
          "nodeFullText": "export type Lens = {\n  runtime: CallbackRegistrer<RuntimePlugin>\n  workflow: CallbackRegistrer<WorkflowDefiner>\n  testing: CallbackRegistrer<TestingPlugin>\n  utils: {\n    log: Logger.Logger\n    runSync: typeof runSync\n    run: typeof run\n    /**\n     * Check out https://github.com/terkelg/prompts for documentation\n     */\n    prompt: PromptsConstructor\n  }\n}"
        }
      },
      "raw": {
        "typeText": "Lens",
        "nodeText": "export type Lens = {\n  runtime: CallbackRegistrer<RuntimePlugin>\n  workflow: CallbackRegistrer<WorkflowDefiner>\n  testing: CallbackRegistrer<TestingPlugin>\n  utils: {\n    log: Logger.Logger\n    runSync: typeof runSync\n    run: typeof run\n    /**\n     * Check out https://github.com/terkelg/prompts for documentation\n     */\n    prompt: PromptsConstructor\n  }\n}",
        "nodeFullText": "export type Lens = {\n  runtime: CallbackRegistrer<RuntimePlugin>\n  workflow: CallbackRegistrer<WorkflowDefiner>\n  testing: CallbackRegistrer<TestingPlugin>\n  utils: {\n    log: Logger.Logger\n    runSync: typeof runSync\n    run: typeof run\n    /**\n     * Check out https://github.com/terkelg/prompts for documentation\n     */\n    prompt: PromptsConstructor\n  }\n}"
      }
    },
    "(lib/utils/index).CallbackRegistrer": {
      "kind": "alias",
      "name": "CallbackRegistrer",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "primitive",
              "type": "void"
            },
            "params": [
              {
                "kind": "sigParam",
                "name": "f",
                "type": {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "F",
                    "nodeText": "F",
                    "nodeFullText": "F"
                  }
                }
              }
            ]
          }
        ],
        "raw": {
          "typeText": "CallbackRegistrer<RuntimePlugin>",
          "nodeText": "export type CallbackRegistrer<F> = (f: F) => void",
          "nodeFullText": "export type CallbackRegistrer<F> = (f: F) => void"
        }
      },
      "raw": {
        "typeText": "CallbackRegistrer<RuntimePlugin>",
        "nodeText": "export type CallbackRegistrer<F> = (f: F) => void",
        "nodeFullText": "export type CallbackRegistrer<F> = (f: F) => void"
      }
    },
    "(utils/process).SuccessfulRunResult": {
      "kind": "alias",
      "name": "SuccessfulRunResult",
      "type": {
        "kind": "object",
        "props": [
          {
            "kind": "prop",
            "name": "command",
            "type": {
              "kind": "primitive",
              "type": "string"
            }
          },
          {
            "kind": "prop",
            "name": "stderr",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "string | null",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "null"
                },
                {
                  "kind": "primitive",
                  "type": "string"
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "stdout",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "string | null",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "null"
                },
                {
                  "kind": "primitive",
                  "type": "string"
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "signal",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "string | null",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "null"
                },
                {
                  "kind": "primitive",
                  "type": "string"
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "exitCode",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "number | null",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "null"
                },
                {
                  "kind": "primitive",
                  "type": "number"
                }
              ]
            }
          },
          {
            "kind": "prop",
            "name": "error",
            "type": {
              "kind": "union",
              "isDiscriminated": false,
              "discriminantProperties": null,
              "raw": {
                "typeText": "Error | null",
                "nodeFullText": "",
                "nodeText": ""
              },
              "types": [
                {
                  "kind": "primitive",
                  "type": "null"
                },
                {
                  "kind": "unsupported",
                  "raw": {
                    "typeText": "Error",
                    "nodeText": "interface Error {\r\n    name: string;\r\n    message: string;\r\n    stack?: string;\r\n}",
                    "nodeFullText": "interface Error {\r\n    name: string;\r\n    message: string;\r\n    stack?: string;\r\n}"
                  }
                }
              ]
            }
          }
        ],
        "raw": {
          "typeText": "SuccessfulRunResult",
          "nodeText": "export type SuccessfulRunResult = {\n  command: string\n  stderr: null | string // present if stdio using pipe mode\n  stdout: null | string // present if stdio using pipe mode\n  signal: null | string\n  exitCode: null | number // present if optional (non-throw) mode\n  error: null | Error // present if optonal (non-throw) mode\n}",
          "nodeFullText": "export type SuccessfulRunResult = {\n  command: string\n  stderr: null | string // present if stdio using pipe mode\n  stdout: null | string // present if stdio using pipe mode\n  signal: null | string\n  exitCode: null | number // present if optional (non-throw) mode\n  error: null | Error // present if optonal (non-throw) mode\n}"
        }
      },
      "raw": {
        "typeText": "SuccessfulRunResult",
        "nodeText": "export type SuccessfulRunResult = {\n  command: string\n  stderr: null | string // present if stdio using pipe mode\n  stdout: null | string // present if stdio using pipe mode\n  signal: null | string\n  exitCode: null | number // present if optional (non-throw) mode\n  error: null | Error // present if optonal (non-throw) mode\n}",
        "nodeFullText": "export type SuccessfulRunResult = {\n  command: string\n  stderr: null | string // present if stdio using pipe mode\n  stdout: null | string // present if stdio using pipe mode\n  signal: null | string\n  exitCode: null | number // present if optional (non-throw) mode\n  error: null | Error // present if optonal (non-throw) mode\n}"
      }
    },
    "(utils/process).RunOptions": {
      "kind": "alias",
      "name": "RunOptions",
      "type": {
        "kind": "intersection",
        "raw": {
          "typeText": "RunOptions",
          "nodeText": "export type RunOptions = Omit<SpawnSyncOptions, 'encoding'> & {\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}",
          "nodeFullText": "// TODO should not use sync options type for async run\nexport type RunOptions = Omit<SpawnSyncOptions, 'encoding'> & {\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}"
        },
        "types": [
          {
            "kind": "unsupported",
            "raw": {
              "typeText": "Pick<SpawnSyncOptions, \"input\" | \"killSignal\" | \"maxBuffer\" | \"argv0\" | \"stdio\" | \"shell\" | \"windowsVerbatimArguments\" | \"windowsHide\" | \"timeout\" | \"uid\" | \"gid\" | \"cwd\" | \"env\" | \"serialization\">",
              "nodeText": "type Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};",
              "nodeFullText": "/**\r\n * From T, pick a set of properties whose keys are in the union K\r\n */\r\ntype Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};"
            }
          },
          {
            "kind": "object",
            "props": [
              {
                "kind": "prop",
                "name": "envAdditions",
                "type": {
                  "kind": "union",
                  "isDiscriminated": false,
                  "discriminantProperties": null,
                  "raw": {
                    "typeText": "Record<string, string | undefined> | undefined",
                    "nodeFullText": "",
                    "nodeText": ""
                  },
                  "types": [
                    {
                      "kind": "primitive",
                      "type": "undefined"
                    },
                    {
                      "kind": "alias",
                      "name": "Record",
                      "type": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "Record<string, string | undefined>",
                          "nodeText": "type Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};",
                          "nodeFullText": "/**\r\n * Construct a type with a set of properties K of type T\r\n */\r\ntype Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};"
                        }
                      },
                      "raw": {
                        "typeText": "Record<string, string | undefined>",
                        "nodeText": "type Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};",
                        "nodeFullText": "/**\r\n * Construct a type with a set of properties K of type T\r\n */\r\ntype Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};"
                      }
                    }
                  ]
                }
              },
              {
                "kind": "prop",
                "name": "require",
                "type": {
                  "kind": "union",
                  "isDiscriminated": false,
                  "discriminantProperties": null,
                  "raw": {
                    "typeText": "boolean | undefined",
                    "nodeFullText": "",
                    "nodeText": ""
                  },
                  "types": [
                    {
                      "kind": "primitive",
                      "type": "undefined"
                    },
                    {
                      "kind": "literal",
                      "name": "false",
                      "base": "boolean"
                    },
                    {
                      "kind": "literal",
                      "name": "true",
                      "base": "boolean"
                    }
                  ]
                }
              }
            ],
            "raw": {
              "typeText": "{ envAdditions?: Record<string, string | undefined> | undefined; require?: boolean | undefined; }",
              "nodeText": "{\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}",
              "nodeFullText": "{\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}"
            }
          }
        ]
      },
      "raw": {
        "typeText": "RunOptions",
        "nodeText": "export type RunOptions = Omit<SpawnSyncOptions, 'encoding'> & {\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}",
        "nodeFullText": "// TODO should not use sync options type for async run\nexport type RunOptions = Omit<SpawnSyncOptions, 'encoding'> & {\n  envAdditions?: Record<string, string | undefined>\n  require?: boolean\n}"
      }
    },
    "(core/plugin/index).PromptsConstructor": {
      "kind": "alias",
      "name": "PromptsConstructor",
      "type": {
        "kind": "callable",
        "isOverloaded": false,
        "hasProps": false,
        "props": [],
        "sigs": [
          {
            "kind": "sig",
            "return": {
              "kind": "unsupported",
              "raw": {
                "typeText": "Promise<Answers<T>>",
                "nodeText": "interface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}",
                "nodeFullText": "/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}"
              }
            },
            "params": [
              {
                "kind": "sigParam",
                "name": "questions",
                "type": {
                  "kind": "union",
                  "isDiscriminated": false,
                  "discriminantProperties": null,
                  "raw": {
                    "typeText": "PromptObject<T> | PromptObject<T>[]",
                    "nodeFullText": "",
                    "nodeText": ""
                  },
                  "types": [
                    {
                      "kind": "unsupported",
                      "raw": {
                        "typeText": "PromptObject<T>",
                        "nodeText": "interface PromptObject<T extends string = string> {\n        type: PromptType | Falsy | PrevCaller<T, PromptType | Falsy>;\n        name: ValueOrFunc<T>;\n        message?: ValueOrFunc<string>;\n        initial?: string | number | boolean | Date;\n        style?: string;\n        format?: PrevCaller<T, void>;\n        validate?: PrevCaller<T, boolean | string | Promise<boolean | string>>;\n        onState?: PrevCaller<T, void>;\n        min?: number;\n        max?: number;\n        float?: boolean;\n        round?: number;\n        increment?: number;\n        seperator?: string;\n        active?: string;\n        inactive?: string;\n        choices?: Choice[];\n        hint?: string;\n        suggest?: ((input: any, choices: Choice[]) => Promise<any>);\n        limit?: number;\n        mask?: string;\n    }",
                        "nodeFullText": "interface PromptObject<T extends string = string> {\n        type: PromptType | Falsy | PrevCaller<T, PromptType | Falsy>;\n        name: ValueOrFunc<T>;\n        message?: ValueOrFunc<string>;\n        initial?: string | number | boolean | Date;\n        style?: string;\n        format?: PrevCaller<T, void>;\n        validate?: PrevCaller<T, boolean | string | Promise<boolean | string>>;\n        onState?: PrevCaller<T, void>;\n        min?: number;\n        max?: number;\n        float?: boolean;\n        round?: number;\n        increment?: number;\n        seperator?: string;\n        active?: string;\n        inactive?: string;\n        choices?: Choice[];\n        hint?: string;\n        suggest?: ((input: any, choices: Choice[]) => Promise<any>);\n        limit?: number;\n        mask?: string;\n    }"
                      }
                    },
                    {
                      "kind": "array",
                      "innerType": {
                        "kind": "unsupported",
                        "raw": {
                          "typeText": "PromptObject<T>",
                          "nodeText": "interface PromptObject<T extends string = string> {\n        type: PromptType | Falsy | PrevCaller<T, PromptType | Falsy>;\n        name: ValueOrFunc<T>;\n        message?: ValueOrFunc<string>;\n        initial?: string | number | boolean | Date;\n        style?: string;\n        format?: PrevCaller<T, void>;\n        validate?: PrevCaller<T, boolean | string | Promise<boolean | string>>;\n        onState?: PrevCaller<T, void>;\n        min?: number;\n        max?: number;\n        float?: boolean;\n        round?: number;\n        increment?: number;\n        seperator?: string;\n        active?: string;\n        inactive?: string;\n        choices?: Choice[];\n        hint?: string;\n        suggest?: ((input: any, choices: Choice[]) => Promise<any>);\n        limit?: number;\n        mask?: string;\n    }",
                          "nodeFullText": "interface PromptObject<T extends string = string> {\n        type: PromptType | Falsy | PrevCaller<T, PromptType | Falsy>;\n        name: ValueOrFunc<T>;\n        message?: ValueOrFunc<string>;\n        initial?: string | number | boolean | Date;\n        style?: string;\n        format?: PrevCaller<T, void>;\n        validate?: PrevCaller<T, boolean | string | Promise<boolean | string>>;\n        onState?: PrevCaller<T, void>;\n        min?: number;\n        max?: number;\n        float?: boolean;\n        round?: number;\n        increment?: number;\n        seperator?: string;\n        active?: string;\n        inactive?: string;\n        choices?: Choice[];\n        hint?: string;\n        suggest?: ((input: any, choices: Choice[]) => Promise<any>);\n        limit?: number;\n        mask?: string;\n    }"
                        }
                      }
                    }
                  ]
                }
              },
              {
                "kind": "sigParam",
                "name": "options",
                "type": {
                  "kind": "union",
                  "isDiscriminated": false,
                  "discriminantProperties": null,
                  "raw": {
                    "typeText": "Options | undefined",
                    "nodeFullText": "",
                    "nodeText": ""
                  },
                  "types": [
                    {
                      "kind": "primitive",
                      "type": "undefined"
                    },
                    {
                      "kind": "unsupported",
                      "raw": {
                        "typeText": "Options",
                        "nodeText": "interface Options {\n        onSubmit?: (prompt: PromptObject, answer: any, answers: any[]) => void;\n        onCancel?: (prompt: PromptObject, answers: any) => void;\n    }",
                        "nodeFullText": "interface Options {\n        onSubmit?: (prompt: PromptObject, answer: any, answers: any[]) => void;\n        onCancel?: (prompt: PromptObject, answers: any) => void;\n    }"
                      }
                    }
                  ]
                }
              }
            ]
          }
        ],
        "raw": {
          "typeText": "PromptsConstructor",
          "nodeText": "type PromptsConstructor = <T extends string = string>(\n  questions: Prompts.PromptObject<T> | Array<Prompts.PromptObject<T>>,\n  options?: Prompts.Options\n) => Promise<Prompts.Answers<T>>",
          "nodeFullText": "type PromptsConstructor = <T extends string = string>(\n  questions: Prompts.PromptObject<T> | Array<Prompts.PromptObject<T>>,\n  options?: Prompts.Options\n) => Promise<Prompts.Answers<T>>"
        }
      },
      "raw": {
        "typeText": "PromptsConstructor",
        "nodeText": "type PromptsConstructor = <T extends string = string>(\n  questions: Prompts.PromptObject<T> | Array<Prompts.PromptObject<T>>,\n  options?: Prompts.Options\n) => Promise<Prompts.Answers<T>>",
        "nodeFullText": "type PromptsConstructor = <T extends string = string>(\n  questions: Prompts.PromptObject<T> | Array<Prompts.PromptObject<T>>,\n  options?: Prompts.Options\n) => Promise<Prompts.Answers<T>>"
      }
    }
  }
}
